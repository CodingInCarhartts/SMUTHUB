REPOSITORY SUMMARY:

Files: 59
Directories: 10
Total Size: 301.29 KB
Binary Files: 0
Extensions: css, json, ts, tsx
SECURITY CHECK:

Security check was disabled.


FILES:

FILE: rspeedy-env.d.ts
SIZE: 378 bytes
TYPE: ts

CONTENT:
/// <reference types="@lynx-js/rspeedy/client" />

declare module '@lynx-js/types' {
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  interface GlobalProps {
    /**
     * Define your global properties in this interface.
     * These types will be accessible through `lynx.__globalProps`.
     */
  }
}

// This export makes the file a module
export {};


--------------------------------

FILE: index.tsx
SIZE: 162 bytes
TYPE: tsx

CONTENT:
import { root } from '@lynx-js/react';
import { App } from './App.js';

root.render(<App />);

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
}


--------------------------------

FILE: services/settings.ts
SIZE: 3.75 KB
TYPE: ts

CONTENT:
// Settings store with Supabase sync
import { type AppSettings, StorageService, storageReady } from './storage';

let settings: AppSettings = StorageService.getSettingsSync();

let isInitialized = false;
let initializationPromise: Promise<void> | null = null;

const listeners: Set<() => void> = new Set();

// Initialize from native storage first, then Supabase
const initPromise = storageReady
  .then(() => {
    console.log('[SettingsStore] Storage ready, loading settings...');
    // Re-read from storage now that native data is loaded
    settings = StorageService.getSettingsSync();
    listeners.forEach((fn) => fn());

    // Then try cloud
    return StorageService.getSettings();
  })
  .then((result) => {
    console.log('[SettingsStore] Cloud settings loaded:', result.data);
    settings = result.data;
    isInitialized = true;
    listeners.forEach((fn) => fn());
  })
  .catch((e) => {
    console.error('[SettingsStore] Failed to load settings:', e);
    isInitialized = true;
    listeners.forEach((fn) => fn());
  });

export const SettingsStore = {
  isInitialized(): boolean {
    return isInitialized;
  },

  waitForInitialization(): Promise<void> {
    if (isInitialized) {
      return Promise.resolve();
    }
    if (!initializationPromise) {
      initializationPromise = initPromise;
    }
    return initializationPromise;
  },

  get(): AppSettings {
    return { ...settings };
  },

  getDarkMode(): boolean {
    return settings.darkMode;
  },

  getDevMode(): boolean {
    return settings.devMode;
  },

  getScrollSpeed(): number {
    return settings.scrollSpeed ?? 0.15;
  },

  setDarkMode(enabled: boolean): void {
    console.log('[SettingsStore] Toggling dark mode to:', enabled);
    settings.darkMode = enabled;
    StorageService.saveSettings({ darkMode: enabled });
    listeners.forEach((fn) => fn());
  },

  setDevMode(enabled: boolean): void {
    console.log('[SettingsStore] Developer mode set to:', enabled);
    settings.devMode = enabled;
    StorageService.saveSettings({ devMode: enabled });
    listeners.forEach((fn) => fn());
  },

  setScrollSpeed(speed: number): void {
    console.log('[SettingsStore] Scroll speed set to:', speed);
    settings.scrollSpeed = speed;
    StorageService.saveSettings({ scrollSpeed: speed });
    listeners.forEach((fn) => fn());
  },

  getDebugOutlines(): boolean {
    return settings.debugOutlines ?? false;
  },

  setDebugOutlines(enabled: boolean): void {
    console.log('[SettingsStore] Debug outlines set to:', enabled);
    settings.debugOutlines = enabled;
    StorageService.saveSettings({ debugOutlines: enabled });
    listeners.forEach((fn) => fn());
  },

  getPrivacyFilter(): boolean {
    return settings.privacyFilter ?? false;
  },

  setPrivacyFilter(enabled: boolean): void {
    console.log('[SettingsStore] Privacy filter set to:', enabled);
    settings.privacyFilter = enabled;
    StorageService.saveSettings({ privacyFilter: enabled });
    listeners.forEach((fn) => fn());
  },

  getPrivacyFilterOpacity(): number {
    return settings.privacyFilterOpacity ?? 0.7;
  },

  setPrivacyFilterOpacity(opacity: number): void {
    console.log('[SettingsStore] Privacy filter opacity set to:', opacity);
    settings.privacyFilterOpacity = opacity;
    StorageService.saveSettings({ privacyFilterOpacity: opacity });
    listeners.forEach((fn) => fn());
  },

  subscribe(listener: () => void): () => void {
    listeners.add(listener);
    return () => listeners.delete(listener);
  },

  getMockUpdates(): boolean {
    return settings.mockUpdates ?? false;
  },

  setMockUpdates(enabled: boolean): void {
    console.log('[SettingsStore] Mock updates set to:', enabled);
    settings.mockUpdates = enabled;
    StorageService.saveSettings({ mockUpdates: enabled });
    listeners.forEach((fn) => fn());
  },
};


--------------------------------

FILE: services/__tests__/storageLogic.test.ts
SIZE: 1.19 KB
TYPE: ts

CONTENT:
import { describe, expect, it, vi } from 'vitest';
import { normalizeUrl } from '../../services/storage';

// Mock native storage to prevent "NativeModules is not defined" error
vi.mock('../../services/nativeStorage', () => ({
  getNativeItem: vi.fn(),
  setNativeItem: vi.fn(),
  hasNativeStorage: () => false,
}));

describe('Storage Logic', () => {
  describe('normalizeUrl', () => {
    it('should return empty string for undefined/null/empty', () => {
      expect(normalizeUrl(undefined)).toBe('');
      expect(normalizeUrl('')).toBe('');
    });

    it('should remove trailing slashes', () => {
      expect(normalizeUrl('https://example.com/chapter/1/')).toBe(
        'https://example.com/chapter/1',
      );
      expect(normalizeUrl('https://example.com/chapter/1///')).toBe(
        'https://example.com/chapter/1',
      );
    });

    it('should lowercase the URL', () => {
      expect(normalizeUrl('HTTPS://EXAMPLE.COM/Chapter/1')).toBe(
        'https://example.com/chapter/1',
      );
    });

    it('should handle URLs without trailing slashes correctly', () => {
      expect(normalizeUrl('https://example.com/chapter/1')).toBe(
        'https://example.com/chapter/1',
      );
    });
  });
});


--------------------------------

FILE: services/__tests__/update.test.ts
SIZE: 1.89 KB
TYPE: ts

CONTENT:
import { describe, expect, it } from 'vitest';

/**
 * Note: We can't directly import UpdateService because it has Lynx-specific dependencies.
 * Instead, we'll re-implement the pure function logic here for testing.
 */

/**
 * Compare two semver strings
 * Returns:
 *   1 if v1 > v2
 *  -1 if v1 < v2
 *   0 if v1 == v2
 */
function compareVersions(v1: string, v2: string): number {
  const parts1 = v1.split('.').map((p) => parseInt(p, 10) || 0);
  const parts2 = v2.split('.').map((p) => parseInt(p, 10) || 0);

  const length = Math.max(parts1.length, parts2.length);
  for (let i = 0; i < length; i++) {
    const p1 = parts1[i] || 0;
    const p2 = parts2[i] || 0;
    if (p1 > p2) return 1;
    if (p1 < p2) return -1;
  }
  return 0;
}

describe('UpdateService', () => {
  describe('compareVersions', () => {
    it('should return 0 for equal versions', () => {
      expect(compareVersions('1.0.0', '1.0.0')).toBe(0);
      expect(compareVersions('2.5.3', '2.5.3')).toBe(0);
    });

    it('should return 1 when v1 > v2', () => {
      expect(compareVersions('1.0.1', '1.0.0')).toBe(1);
      expect(compareVersions('2.0.0', '1.9.9')).toBe(1);
      expect(compareVersions('1.1.0', '1.0.9')).toBe(1);
    });

    it('should return -1 when v1 < v2', () => {
      expect(compareVersions('1.0.0', '1.0.1')).toBe(-1);
      expect(compareVersions('1.9.9', '2.0.0')).toBe(-1);
      expect(compareVersions('1.0.9', '1.1.0')).toBe(-1);
    });

    it('should handle different version lengths', () => {
      expect(compareVersions('1.0', '1.0.0')).toBe(0);
      expect(compareVersions('1.0.0', '1')).toBe(0);
      expect(compareVersions('1.0.1', '1.0')).toBe(1);
      expect(compareVersions('1.0', '1.0.1')).toBe(-1);
    });

    it('should handle pre-release style versions', () => {
      expect(compareVersions('1.0.84', '1.0.83')).toBe(1);
      expect(compareVersions('1.0.83', '1.0.84')).toBe(-1);
    });
  });
});


--------------------------------

FILE: services/__tests__/mangapark_live.test.ts
SIZE: 1.29 KB
TYPE: ts

CONTENT:
import { describe, expect, it } from 'vitest';
import { MangaparkService } from '../mangapark';

describe('MangaparkService (MangaKatana Mirror)', () => {
  it('should search for manga', async () => {
    const results = await MangaparkService.search('Solo Leveling');
    expect(results.length).toBeGreaterThan(0);
    expect(results[0].title).toContain('Solo Leveling');
    expect(results[0].id).toContain('mangapark:');
    expect(results[0].url).toContain('mangakatana.com');
  }, 15000);

  it('should get manga details', async () => {
    const details = await MangaparkService.getMangaDetails(
      'https://mangakatana.com/manga/solo-leveling.21708',
    );
    expect(details).not.toBeNull();
    expect(details?.title).toBe('Solo Leveling');
    expect(details?.chapters.length).toBeGreaterThan(0);
  }, 15000);

  it('should get chapter pages', async () => {
    const pages = await MangaparkService.getChapterPages(
      'https://mangakatana.com/manga/solo-leveling.21708/c200',
    );
    expect(pages.length).toBeGreaterThan(0);
    expect(pages[0]).toContain('http');
  }, 15000);

  it('should get home feed', async () => {
    const feed = await MangaparkService.getHomeFeed();
    expect(feed.popular.length).toBeGreaterThan(0);
    expect(feed.latest.length).toBeGreaterThan(0);
  }, 15000);
});


--------------------------------

FILE: services/debugLog.ts
SIZE: 2.92 KB
TYPE: ts

CONTENT:
// SAFE DEBUG LOG SERVICE
// Captures logs in memory for on-device viewing without crashing the Lynx runtime

export type LogCategory =
  | 'INIT'
  | 'NETWORK'
  | 'SYNC'
  | 'UI'
  | 'STORAGE'
  | 'UPDATE'
  | 'PERF'
  | 'GENERAL';

export interface LogEntry {
  timestamp: string;
  category: string;
  level: 'log' | 'warn' | 'error';
  message: string;
  args?: any[];
}

const MAX_LOGS = 1000;
const logs: LogEntry[] = [];

function addLog(
  level: 'log' | 'warn' | 'error',
  category: string,
  message: string,
  ...args: any[]
) {
  const entry: LogEntry = {
    timestamp: new Date().toISOString(),
    category,
    level,
    message,
    args: args.length > 0 ? args : undefined,
  };

  logs.push(entry);
  if (logs.length > MAX_LOGS) {
    logs.shift();
  }

  // Still call native console
  if (level === 'error') console.error(`[${category}] ${message}`, ...args);
  else if (level === 'warn') console.warn(`[${category}] ${message}`, ...args);
  else console.log(`[${category}] ${message}`, ...args);
}

export function logCapture(level: any, ...args: any[]) {
  addLog(level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log', 'GENERAL', args[0]?.toString() || '', ...args.slice(1));
}

export const DebugLogService = {
  log(category: string, message: string, ...args: any[]): void {
    addLog('log', category, message, ...args);
  },
  warn(category: string, message: string, ...args: any[]): void {
    addLog('warn', category, message, ...args);
  },
  error(
    category: string,
    message: string,
    error?: Error,
    ...args: any[]
  ): void {
    addLog('error', category, `${message}${error ? `: ${error.message}` : ''}`, ...args);
  },
  reportError(category: string, context: string, error: Error): void {
    addLog('error', category, `ERROR in ${context}: ${error.message}`);
  },
  getLogs(): LogEntry[] {
    return [...logs];
  },
  getLogsAsText(): string {
    return logs
      .map(
        (l) =>
          `[${l.timestamp.split('T')[1].split('.')[0]}] [${l.level.toUpperCase()}] [${l.category}] ${l.message}`,
      )
      .join('\n');
  },
  getStructuredReport(context?: any): any {
    return {
      app_version: context?.version || 'Unknown',
      timestamp: new Date().toISOString(),
      environment_info: {
        platform: typeof lynx !== 'undefined' ? 'Lynx' : 'Web/Unknown',
        deviceId: context?.deviceId || 'Unknown',
      },
      settings: context?.settings || {},
      storage_state: context?.storageValues || {},
      console_logs: this.getLogsAsText().split('\n'),
    };
  },
  getDebugReport(context?: any): string {
    const report = this.getStructuredReport(context);
    let text = `=== VERSION: ${report.app_version} ===\n`;
    text += `=== DEVICE ID: ${report.environment_info.deviceId} ===\n\n`;
    text += `--- LOGS (${logs.length}) ---\n`;
    text += this.getLogsAsText();
    return text;
  },
  clear(): void {
    logs.length = 0;
  },
  count(): number {
    return logs.length;
  },
};


--------------------------------

FILE: services/migration.ts
SIZE: 2.94 KB
TYPE: ts

CONTENT:
import { StorageService } from './storage';
import { SupabaseService } from './supabase';
import { SyncEngine } from './sync';

const MIGRATION_FLAG = 'batoto:migration_complete';

/**
 * Migration Service: Legacy -> Cloud
 */
export const MigrationService = {
  /**
   * Run the migration process if not already completed
   */
  async run(): Promise<void> {
    const isComplete = await StorageService.getNativeItemSync(MIGRATION_FLAG);
    if (isComplete === 'true') {
      console.log('[Migration] Already complete');
      return;
    }

    console.log('[Migration] Starting legacy data migration...');

    try {
      const deviceId = await StorageService.getDeviceId();
      if (!deviceId) {
        console.warn('[Migration] No device ID, skipping migration');
        return;
      }

      // 1. Migrate Favorites
      const favoritesResult = await StorageService.getFavorites();
      const favorites = favoritesResult.data;
      if (favorites.length > 0) {
        console.log(`[Migration] Migrating ${favorites.length} favorites...`);
        const payload = favorites.map((m) => ({
          device_id: deviceId,
          manga_id: m.id,
          manga_data: m,
          created_at: new Date().toISOString(),
        }));
        await SupabaseService.upsert(
          'favorites',
          payload,
          'device_id,manga_id',
        );
      }

      // 2. Migrate History
      const historyResult = await StorageService.getHistory();
      const history = historyResult.data;
      if (history.length > 0) {
        console.log(`[Migration] Migrating ${history.length} history items...`);
        const payload = history.map((h) => ({
          device_id: deviceId,
          manga_id: h.manga.id,
          manga_data: h.manga,
          chapter_id: h.lastChapterId,
          chapter_title: h.lastChapterTitle,
          page_index: h.lastPageIndex,
          timestamp: h.timestamp,
          updated_at: h.viewedAt,
        }));
        await SupabaseService.upsert('history', payload, 'device_id,manga_id');
      }

      // 3. Migrate Settings
      const settingsResult = await StorageService.getSettings();
      const settings = settingsResult.data;
      if (settings) {
        console.log('[Migration] Migrating settings...');
        await SupabaseService.upsert(
          'settings',
          {
            device_id: deviceId,

            dark_mode: settings.darkMode,
            dev_mode: settings.devMode,
            scroll_speed: settings.scrollSpeed,
            updated_at: new Date().toISOString(),
          },
          'device_id',
        );
      }

      // 4. Mark as complete
      await StorageService.setNativeItemSync(MIGRATION_FLAG, 'true');
      console.log('[Migration] Successfully completed');

      // Note: Per user feedback, we don't strictly need to clear legacy keys immediately,
      // but they will be ignored by the new StorageService anyway.
    } catch (e) {
      console.error('[Migration] Failed:', e);
    }
  },
};


--------------------------------

FILE: services/nativeStorage.ts
SIZE: 2.36 KB
TYPE: ts

CONTENT:
import { logCapture } from './debugLog';

// Helper to log with capture
const log = (...args: any[]) => logCapture('log', ...args);
const logError = (...args: any[]) => logCapture('error', ...args);

// Check if native module is available
export function hasNativeStorage(): boolean {
  try {
    const hasMods = typeof NativeModules !== 'undefined';
    const hasStorageMod = hasMods && !!NativeModules.NativeLocalStorageModule;
    log('[Storage] hasNativeStorage check:', { hasMods, hasStorageMod });
    return hasStorageMod;
  } catch (e) {
    logError('[Storage] hasNativeStorage error:', e);
    return false;
  }
}

// Async getter using native module
export function getNativeItem(key: string): Promise<string | null> {
  return new Promise((resolve) => {
    try {
      const nativeModule = NativeModules?.NativeLocalStorageModule;
      if (nativeModule && typeof nativeModule.getStorageItem === 'function') {
        nativeModule.getStorageItem(key, (value: string | null) => {
          log('[getNativeItem] Got value for:', key);
          resolve(value);
        });
      } else {
        resolve(null);
      }
    } catch (e) {
      logError('[getNativeItem] Error:', e);
      resolve(null);
    }
  });
}

// Async setter using native module (wait for completion)
export function setNativeItem(key: string, value: string): Promise<void> {
  return new Promise((resolve) => {
    try {
      const nativeModule = NativeModules?.NativeLocalStorageModule;
      if (nativeModule && typeof nativeModule.setStorageItem === 'function') {
        // Check if it accepts a callback (some implementations might)
        // If not, we just assume it's fired.
        // But to be safe, let's wrap it.
        nativeModule.setStorageItem(key, value);
        log('[setNativeItem] Saved:', { key, valueLen: value.length });
        // Give it a tiny tick to ensure it hits the bridge?
        // Or if the native API provides a callback, use it.
        // Assuming standard bridge might be async.
        setTimeout(resolve, 50);
      } else {
        resolve();
      }
    } catch (e) {
      logError('[setNativeItem] Error:', e);
      resolve();
    }
  });
}

// Export for SyncEngine
export async function getNativeItemSync(key: string): Promise<string | null> {
  return await getNativeItem(key);
}
export function setNativeItemSync(key: string, value: string): void {
  setNativeItem(key, value);
}


--------------------------------

FILE: services/networkLog.ts
SIZE: 1.89 KB
TYPE: ts

CONTENT:
export interface NetworkRequest {
  id: string;
  method: string;
  url: string;
  startTime: number;
  endTime?: number;
  status?: number;
  statusText?: string;
  requestHeaders?: Record<string, string>;
  responseHeaders?: Record<string, string>;
  responseBodyPreview?: string;
  duration?: number;
  error?: string;
}

const MAX_LOGS = 50;

export const NetworkLogService = {
  logs: [] as NetworkRequest[],
  listeners: new Set<() => void>(),

  logRequest(
    method: string,
    url: string,
    headers?: Record<string, string>,
  ): string {
    const id = Math.random().toString(36).substring(7);
    const req: NetworkRequest = {
      id,
      method,
      url,
      startTime: Date.now(),
      requestHeaders: headers,
    };

    this.logs.unshift(req);
    if (this.logs.length > MAX_LOGS) {
      this.logs = this.logs.slice(0, MAX_LOGS);
    }
    this.notify();
    return id;
  },

  logResponse(
    id: string,
    status: number,
    statusText: string,
    headers?: Record<string, string>,
    bodyPreview?: string,
  ) {
    const req = this.logs.find((r) => r.id === id);
    if (req) {
      req.endTime = Date.now();
      req.duration = req.endTime - req.startTime;
      req.status = status;
      req.statusText = statusText;
      req.responseHeaders = headers;
      req.responseBodyPreview = bodyPreview;
      this.notify();
    }
  },

  logError(id: string, error: string) {
    const req = this.logs.find((r) => r.id === id);
    if (req) {
      req.endTime = Date.now();
      req.duration = req.endTime - req.startTime;
      req.error = error;
      req.status = 0;
      this.notify();
    }
  },

  getLogs() {
    return [...this.logs];
  },

  clear() {
    this.logs = [];
    this.notify();
  },

  subscribe(listener: () => void) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  },

  notify() {
    this.listeners.forEach((l) => l());
  },
};


--------------------------------

FILE: services/perf.ts
SIZE: 6.48 KB
TYPE: ts

CONTENT:
/**
 * Performance Monitoring Service
 * Tracks battery, memory, and operation durations to identify hotspots.
 */

import { logCapture } from './debugLog';

// Helper to log with capture
const log = (...args: any[]) => logCapture('log', ...args);
const logWarn = (...args: any[]) => logCapture('warn', ...args);

// ============================================================
// Types
// ============================================================

export interface BatteryStatus {
  level: number; // 0-100, or -1 if unavailable
  isCharging: boolean;
  temperature: number; // Celsius
}

export interface MemoryInfo {
  usedMb: number;
  maxMb: number;
  pssMb: number; // Process-specific memory
}

export interface PerfSnapshot {
  timestamp: number;
  battery: BatteryStatus;
  memory: MemoryInfo;
}

interface OperationTimer {
  name: string;
  startTime: number;
}

// ============================================================
// State
// ============================================================

const snapshots: PerfSnapshot[] = [];
const MAX_SNAPSHOTS = 100;
const activeTimers: Map<string, OperationTimer> = new Map();

// ============================================================
// Native Bridge Wrappers
// ============================================================

function getBatteryStatus(): Promise<BatteryStatus> {
  return new Promise((resolve) => {
    try {
      const utilsModule = (NativeModules as any)?.NativeUtilsModule;
      if (utilsModule && typeof utilsModule.getBatteryStatus === 'function') {
        utilsModule.getBatteryStatus((json: string) => {
          try {
            resolve(JSON.parse(json));
          } catch {
            resolve({ level: -1, isCharging: false, temperature: 0 });
          }
        });
      } else {
        resolve({ level: -1, isCharging: false, temperature: 0 });
      }
    } catch {
      resolve({ level: -1, isCharging: false, temperature: 0 });
    }
  });
}

function getMemoryInfo(): Promise<MemoryInfo> {
  return new Promise((resolve) => {
    try {
      const utilsModule = (NativeModules as any)?.NativeUtilsModule;
      if (utilsModule && typeof utilsModule.getMemoryInfo === 'function') {
        utilsModule.getMemoryInfo((json: string) => {
          try {
            resolve(JSON.parse(json));
          } catch {
            resolve({ usedMb: 0, maxMb: 0, pssMb: 0 });
          }
        });
      } else {
        resolve({ usedMb: 0, maxMb: 0, pssMb: 0 });
      }
    } catch {
      resolve({ usedMb: 0, maxMb: 0, pssMb: 0 });
    }
  });
}

// ============================================================
// Performance Service
// ============================================================

export const PerformanceService = {
  /**
   * Take a snapshot of current battery and memory status
   */
  async snapshot(): Promise<PerfSnapshot> {
    const [battery, memory] = await Promise.all([
      getBatteryStatus(),
      getMemoryInfo(),
    ]);

    const snap: PerfSnapshot = {
      timestamp: Date.now(),
      battery,
      memory,
    };

    snapshots.push(snap);
    if (snapshots.length > MAX_SNAPSHOTS) {
      snapshots.shift();
    }

    const drainRate = this.calculateDrainRate();
    const drainMsg =
      drainRate !== null ? ` | Drain: ${drainRate.toFixed(2)}%/min` : '';

    log(
      '[PERF] Snapshot:',
      JSON.stringify({
        battery: `${battery.level}%${battery.isCharging ? ' (charging)' : ''}${drainMsg}`,
        memory: `${memory.usedMb.toFixed(1)}MB / ${memory.maxMb.toFixed(1)}MB`,
      }),
    );

    return snap;
  },

  /**
   * Get all recorded snapshots
   */
  getSnapshots(): PerfSnapshot[] {
    return [...snapshots];
  },

  /**
   * Get the latest snapshot without recording a new one
   */
  getLatest(): PerfSnapshot | null {
    return snapshots.length > 0 ? snapshots[snapshots.length - 1] : null;
  },

  /**
   * Start timing an operation
   */
  startTimer(operationName: string): void {
    activeTimers.set(operationName, {
      name: operationName,
      startTime: Date.now(),
    });
  },

  /**
   * End timing an operation and log the duration
   */
  endTimer(operationName: string): number {
    const timer = activeTimers.get(operationName);
    if (!timer) {
      logWarn(`[PERF] Timer not found: ${operationName}`);
      return 0;
    }

    const duration = Date.now() - timer.startTime;
    activeTimers.delete(operationName);

    // Log if operation took longer than expected
    if (duration > 1000) {
      logWarn(`[PERF] SLOW: ${operationName} took ${duration}ms`);
    } else {
      log(`[PERF] ${operationName}: ${duration}ms`);
    }

    return duration;
  },

  /**
   * Calculate battery drain rate from snapshots
   * Returns percentage per minute
   */
  calculateDrainRate(): number | null {
    const nonChargingSnaps = snapshots.filter(
      (s) => !s.battery.isCharging && s.battery.level >= 0,
    );
    if (nonChargingSnaps.length < 2) return null;

    const first = nonChargingSnaps[0];
    const last = nonChargingSnaps[nonChargingSnaps.length - 1];
    const timeDiffMinutes = (last.timestamp - first.timestamp) / 60000;
    const levelDiff = first.battery.level - last.battery.level;

    if (timeDiffMinutes < 1) return null;

    return levelDiff / timeDiffMinutes;
  },

  /**
   * Get a summary report of performance metrics
   */
  getSummary(): string {
    const latest = this.getLatest();
    const drainRate = this.calculateDrainRate();

    const lines: string[] = ['--- PERFORMANCE SUMMARY ---'];

    if (latest) {
      lines.push(
        `Battery: ${latest.battery.level}%${latest.battery.isCharging ? ' (charging)' : ''}`,
      );
      lines.push(`Temperature: ${latest.battery.temperature}°C`);
      lines.push(
        `Memory: ${latest.memory.usedMb.toFixed(1)}MB / ${latest.memory.maxMb.toFixed(1)}MB`,
      );
      lines.push(`PSS Memory: ${latest.memory.pssMb.toFixed(1)}MB`);
    }

    if (drainRate !== null) {
      lines.push(`Battery Drain: ${drainRate.toFixed(2)}%/min`);
      if (drainRate > 1) {
        lines.push('⚠️ HIGH BATTERY DRAIN DETECTED');
      }
    }

    lines.push(`Snapshots recorded: ${snapshots.length}`);
    lines.push('');

    return lines.join('\n');
  },

  /**
   * Clear all recorded data
   */
  clear(): void {
    snapshots.length = 0;
    activeTimers.clear();
  },
};

// Auto-snapshot every 60 seconds in background
if (typeof globalThis !== 'undefined') {
  setInterval(() => {
    PerformanceService.snapshot();
  }, 60000);

  // Take initial snapshot after 5 seconds
  setTimeout(() => {
    PerformanceService.snapshot();
  }, 5000);
}


--------------------------------

FILE: services/storage.ts
SIZE: 31.57 KB
TYPE: ts

CONTENT:
import {
  HISTORY_LIMIT_CLOUD,
  HISTORY_LIMIT_LOCAL,
  NATIVE_DEVICE_ID_TIMEOUT_MS,
} from '../config';
import { logCapture } from './debugLog';
import { MigrationService } from './migration';
import {
  getNativeItem,
  getNativeItemSync,
  hasNativeStorage,
  setNativeItem,
  setNativeItemSync,
} from './nativeStorage';
import { SupabaseService } from './supabase';
import { SyncEngine } from './sync';
import type { Manga, SearchFilters } from './types';

// Helper to log with capture (console override doesn't work in Lynx)
const log = (...args: any[]) => logCapture('log', ...args);
const logError = (...args: any[]) => logCapture('error', ...args);
const logWarn = (...args: any[]) => logCapture('warn', ...args);

export function normalizeUrl(url: string | undefined): string {
  if (!url) return '';
  return url.replace(/\/+$/, '').toLowerCase();
}

// Types
export interface ViewedManga {
  manga: Manga;
  lastChapterId?: string;
  lastChapterTitle?: string;
  lastPageIndex?: number;
  viewedAt: string;
  timestamp?: number; // legacy support for migration
}

export interface AppSettings {
  darkMode: boolean;
  devMode: boolean;
  scrollSpeed: number; // 0.1 = 10%, 0.2 = 20%, etc.
  debugOutlines?: boolean;
  privacyFilter?: boolean;
  privacyFilterOpacity?: number; // 0.0 to 1.0
  mockUpdates?: boolean;
}

export interface ReaderPosition {
  mangaId: string;
  chapterUrl: string;
  panelIndex: number;
  scrollPosition?: number;
  timestamp: string;
}

export type SyncStatus = 'idle' | 'syncing' | 'error';

export interface StorageResult<T> {
  data: T;
  status: SyncStatus;
  lastSyncedAt?: number;
}

const syncStatus: Map<string, SyncStatus> = new Map();
const lastSyncedAt: Map<string, number> = new Map();

let currentWriteRelease: (() => void) | null = null;
let writeLockResolve: ((value: void) => void) | null = null;

function setSyncStatus(key: string, status: SyncStatus): void {
  syncStatus.set(key, status);
  log(`[Storage] Sync status for ${key}: ${status}`);
}

function getSyncStatus(key: string): SyncStatus {
  return syncStatus.get(key) || 'idle';
}

function setLastSynced(key: string, timestamp: number): void {
  lastSyncedAt.set(key, timestamp);
}

function getLastSynced(key: string): number | undefined {
  return lastSyncedAt.get(key);
}

async function acquireWriteLock(key: string): Promise<() => void> {
  while (currentWriteRelease !== null) {
    await new Promise<void>((resolve) => {
      writeLockResolve = resolve;
    });
  }

  return () => {
    currentWriteRelease = null;
    if (writeLockResolve) {
      writeLockResolve();
      writeLockResolve = null;
    }
  };
}

export const STORAGE_KEYS = {
  FAVORITES: 'batoto:favorites',
  HISTORY: 'batoto:history',
  SETTINGS: 'batoto:settings',
  FILTERS: 'batoto:filters',
  DEVICE_ID: 'batoto:device_id',
  READER_POSITION: 'batoto:reader_position',

  SKIPPED_VERSION: 'batoto:skipped_version',
  UPDATE_ATTEMPT: 'batoto:last_update_attempt',
  DEVICE_ID_OVERRIDE: 'batoto:device_id_override',
};

const DEFAULT_SETTINGS: AppSettings = {
  darkMode: false,
  devMode: false,
  scrollSpeed: 0.6, // 60% of screen per scroll
  privacyFilter: false,
  privacyFilterOpacity: 0.7,
};

// In-memory fallback and cache
const memoryStorage = new Map<string, string>();
let NATIVE_DEVICE_ID: string | null = null;
let SESSION_DEVICE_ID: string | null = null;

// Helper for storage - tries localStorage first, then memory cache
function getLocal<T>(key: string, defaultValue: T): T {
  // First check memory cache (populated by async native loads)
  const cached = memoryStorage.get(key);
  if (cached) {
    try {
      return JSON.parse(cached);
    } catch {
      return defaultValue;
    }
  }

  // Try localStorage (won't work in Lynx but kept for web dev)
  try {
    if (typeof localStorage !== 'undefined') {
      const stored = localStorage.getItem(key);
      if (stored) {
        return JSON.parse(stored);
      }
    }
  } catch (e) {
    // Ignore
  }

  return defaultValue;
}

async function setLocal<T>(key: string, value: T): Promise<void> {
  const strValue = JSON.stringify(value);

  // Always update memory cache
  memoryStorage.set(key, strValue);

  // Try localStorage
  try {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem(key, strValue);
    }
  } catch (e) {
    // Ignore
  }

  // Also save to native storage
  return setNativeItem(key, strValue);
}

// Initialize device ID from native storage on startup
async function initializeFromNativeStorage(): Promise<void> {
  log('[Storage] initializeFromNativeStorage starting...');

  if (!hasNativeStorage()) {
    log('[Storage] Native storage not available, skipping init');
    return;
  }

  // Debug: View available modules
  log('[Storage] Available NativeModules:', Object.keys(NativeModules || {}));

  // Pre-fetch device ID from NativeUtilsModule
  try {
    const modules = NativeModules as any;
    const utilsModule = modules?.NativeUtilsModule;
    log('[Storage] Checking NativeUtilsModule:', {
      exists: !!utilsModule,
      hasGetDeviceId: typeof utilsModule?.getDeviceId === 'function',
    });

    if (utilsModule && typeof utilsModule.getDeviceId === 'function') {
      const nativeId: string | null = await new Promise((resolve) => {
        log('[Storage] Calling native getDeviceId...');
        utilsModule.getDeviceId((id: string) => {
          log('[Storage] Fetched native device ID success:', id);
          resolve(id);
        });
        // Timeout just in case
        setTimeout(() => {
          logWarn(
            `[Storage] Native getDeviceId timed out after ${NATIVE_DEVICE_ID_TIMEOUT_MS}ms`,
          );
          resolve(null);
        }, NATIVE_DEVICE_ID_TIMEOUT_MS);
      });

      if (
        nativeId &&
        nativeId.length > 5 &&
        nativeId !== 'android' &&
        nativeId !== 'undefined'
      ) {
        NATIVE_DEVICE_ID = nativeId;
        // Also ensure it is saved locally to avoid regeneration if hardware ID fetch is slow next time
        setLocal(STORAGE_KEYS.DEVICE_ID, nativeId);
      }
    }
  } catch (e) {
    logError('[Storage] Failed to fetch native device ID:', e);
  }

  log('[Storage] Loading from native storage...');

  const keys = [
    STORAGE_KEYS.DEVICE_ID,
    STORAGE_KEYS.SETTINGS,
    STORAGE_KEYS.FAVORITES,
    STORAGE_KEYS.HISTORY,
    STORAGE_KEYS.FILTERS,
    STORAGE_KEYS.READER_POSITION,
    STORAGE_KEYS.UPDATE_ATTEMPT,
    STORAGE_KEYS.SKIPPED_VERSION,
  ];

  for (const key of keys) {
    try {
      const value = await getNativeItem(key);
      if (value) {
        memoryStorage.set(key, value);
        log('[Storage] Loaded from native:', {
          key,
          hasValue: true,
          preview: value.substring(0, 30),
        });
      } else {
        log('[Storage] No value in native for:', key);
      }
    } catch (e) {
      logError('[Storage] Failed to load key:', key, e);
    }
  }

  log('[Storage] Native storage initialization complete');
}

// Storage Service - Hybrid (Local First + Background Sync via REST)
export const StorageService = {
  // ============ DEVICE ID ============

  getDeviceId(): string {
    // 1. Session Cache
    if (SESSION_DEVICE_ID) return SESSION_DEVICE_ID;

    // 1.5 Check Override
    const override = getLocal<string | null>(
      STORAGE_KEYS.DEVICE_ID_OVERRIDE,
      null,
    );
    if (override && override.length > 0) {
      SESSION_DEVICE_ID = override;
      return override;
    }

    // 2. Prioritize Real Native Device ID (fetched during init)
    if (
      NATIVE_DEVICE_ID &&
      NATIVE_DEVICE_ID.length > 5 &&
      NATIVE_DEVICE_ID !== 'android'
    ) {
      SESSION_DEVICE_ID = NATIVE_DEVICE_ID;
      return NATIVE_DEVICE_ID;
    }

    // 3. Check Memory Storage (via getLocal)
    const id = getLocal<string | null>(STORAGE_KEYS.DEVICE_ID, null);
    if (id && typeof id === 'string' && id.length > 5 && id !== 'android') {
      SESSION_DEVICE_ID = id;
      return id;
    }

    // 4. Fallback to SystemInfo
    try {
      const si =
        typeof SystemInfo !== 'undefined'
          ? SystemInfo
          : (globalThis as any).SystemInfo;
      if (si?.deviceId && si.deviceId.length > 5 && si.deviceId !== 'android') {
        const id = si.deviceId;
        setLocal(STORAGE_KEYS.DEVICE_ID, id);
        SESSION_DEVICE_ID = id;
        return id;
      }
    } catch (e) {
      logWarn('[Storage] SystemInfo check failed:', e);
    }

    // 5. Generate Fallback strictly for web/local dev (Lynx Explorer)
    // If we reach here, we have no ID. Generate one.
    const timestamp = Date.now().toString(36);
    const randomPart = Math.random().toString(36).substring(2, 10);
    const newId = `dev-${timestamp}-${randomPart}`;

    log('[Storage] Generating FALLBACK Device ID (Local/Dev):', newId);

    // Persist to memory/local immediately so it survives this session
    setLocal(STORAGE_KEYS.DEVICE_ID, newId);
    SESSION_DEVICE_ID = newId;
    return newId;
  },

  setDeviceId(id: string): void {
    if (id && id.length > 5) {
      setLocal(STORAGE_KEYS.DEVICE_ID, id);
      log('[Storage] Device ID manually updated to:', id);
    }
  },

  setDeviceIdOverride(id: string): void {
    if (id && id.length > 0) {
      setLocal(STORAGE_KEYS.DEVICE_ID_OVERRIDE, id);
      SESSION_DEVICE_ID = id;

      // Clear data caches to force refetch for new persona
      memoryStorage.delete(STORAGE_KEYS.FAVORITES);
      memoryStorage.delete(STORAGE_KEYS.HISTORY);
      memoryStorage.delete(STORAGE_KEYS.SETTINGS);

      log('[Storage] Device ID OVERRIDE set to:', id);
    }
  },

  clearDeviceIdOverride(): void {
    memoryStorage.delete(STORAGE_KEYS.DEVICE_ID_OVERRIDE);
    setNativeItem(STORAGE_KEYS.DEVICE_ID_OVERRIDE, '');
    SESSION_DEVICE_ID = null; // Will trigger re-detection/native fallback next call

    // Clear data caches
    memoryStorage.delete(STORAGE_KEYS.FAVORITES);
    memoryStorage.delete(STORAGE_KEYS.HISTORY);
    memoryStorage.delete(STORAGE_KEYS.SETTINGS);

    log('[Storage] Device ID OVERRIDE cleared');
  },

  // ============ FAVORITES ============

  async syncFavorites(): Promise<Manga[]> {
    const deviceId = this.getDeviceId();
    setSyncStatus('favorites', 'syncing');

    try {
      const cloudData = await SupabaseService.getAll<{ manga_data: Manga }>(
        'favorites',
        `?select=manga_data&device_id=eq.${deviceId}&order=created_at.desc`,
      );

      if (cloudData.length > 0) {
        let cloudFavorites = cloudData.map((row) => row.manga_data);

        const pendingDeletions =
          await SyncEngine.getPendingDeletions('favorites');
        if (pendingDeletions.size > 0) {
          cloudFavorites = cloudFavorites.filter(
            (m) => !pendingDeletions.has(m.id),
          );
        }

        const currentLocal = getLocal<Manga[]>(STORAGE_KEYS.FAVORITES, []);
        const mergedMap = new Map<string, Manga>();

        cloudFavorites.forEach((m) => mergedMap.set(m.id, m));
        currentLocal.forEach((m) => mergedMap.set(m.id, m));

        const mergedFavorites = Array.from(mergedMap.values());
        setLocal(STORAGE_KEYS.FAVORITES, mergedFavorites);
        setLastSynced('favorites', Date.now());
        setSyncStatus('favorites', 'idle');
        return mergedFavorites;
      }

      setSyncStatus('favorites', 'idle');
      return getLocal<Manga[]>(STORAGE_KEYS.FAVORITES, []);
    } catch (e) {
      logError('[Storage] Failed to sync favorites:', e);
      setSyncStatus('favorites', 'error');
      return getLocal<Manga[]>(STORAGE_KEYS.FAVORITES, []);
    }
  },

  async getFavorites(
    forceRefresh: boolean = false,
  ): Promise<StorageResult<Manga[]>> {
    const local = getLocal<Manga[]>(STORAGE_KEYS.FAVORITES, []);
    const status = getSyncStatus('favorites');
    const lastSynced = getLastSynced('favorites');

    if (forceRefresh || status === 'idle') {
      if (forceRefresh || status === 'idle') {
        const release = await acquireWriteLock('favorites');
        try {
          await this.syncFavorites();
        } finally {
          release();
        }
      }
    } else {
      this.syncFavorites();
    }

    return {
      data: getLocal<Manga[]>(STORAGE_KEYS.FAVORITES, []),
      status: getSyncStatus('favorites'),
      lastSyncedAt: getLastSynced('favorites'),
    };
  },

  async addFavorite(manga: Manga): Promise<void> {
    const release = await acquireWriteLock('favorites');
    try {
      const deviceId = this.getDeviceId();
      console.log(
        `[Storage] Adding favorite for manga ${manga.id} (Device: ${deviceId})`,
      );
      const favorites = getLocal<Manga[]>(STORAGE_KEYS.FAVORITES, []);

      if (!favorites.some((m) => m.id === manga.id)) {
        const newFavorites = [manga, ...favorites];
        setLocal(STORAGE_KEYS.FAVORITES, newFavorites);

        await SyncEngine.enqueue({
          type: 'UPSERT',
          table: 'favorites',
          payload: {
            device_id: deviceId,
            manga_id: manga.id,
            manga_data: manga,
            created_at: new Date().toISOString(),
          },
          timestamp: Date.now(),
        });
      } else {
        console.log(`[Storage] Favorite already exists for ${manga.id}`);
      }
    } finally {
      release();
    }
  },

  async removeFavorite(mangaId: string): Promise<void> {
    const release = await acquireWriteLock('favorites');
    try {
      const favorites = getLocal<Manga[]>(STORAGE_KEYS.FAVORITES, []);
      setLocal(
        STORAGE_KEYS.FAVORITES,
        favorites.filter((m) => m.id !== mangaId),
      );

      await SyncEngine.enqueue({
        type: 'DELETE',
        table: 'favorites',
        payload: {
          device_id: this.getDeviceId(),
          manga_id: mangaId,
        },
        timestamp: Date.now(),
      });
    } finally {
      release();
    }
  },

  isFavoriteSync(mangaId: string): boolean {
    const favorites = getLocal<Manga[]>(STORAGE_KEYS.FAVORITES, []);
    return favorites.some((m) => m.id === mangaId);
  },

  async isFavorite(mangaId: string): Promise<boolean> {
    return this.isFavoriteSync(mangaId);
  },

  // ============ HISTORY ============

  async syncHistory(): Promise<ViewedManga[]> {
    const deviceId = this.getDeviceId();
    setSyncStatus('history', 'syncing');

    try {
      const cloudData = await SupabaseService.getAll<any>(
        'history',
        `?select=manga_data,last_chapter_id,last_chapter_title,viewed_at&device_id=eq.${deviceId}&order=viewed_at.desc&limit=${HISTORY_LIMIT_CLOUD}`,
      );

      if (cloudData.length > 0) {
        const cloudHistory: ViewedManga[] = cloudData.map((row: any) => ({
          manga: row.manga_data,
          lastChapterId: row.last_chapter_id,
          lastChapterTitle: row.last_chapter_title,
          viewedAt: row.viewed_at,
        }));

        const mergedMap = new Map<string, ViewedManga>();

        cloudHistory.forEach((item) => {
          mergedMap.set(item.manga.id, item);
        });

        const currentLocal = getLocal<ViewedManga[]>(STORAGE_KEYS.HISTORY, []);

        currentLocal.forEach((localItem) => {
          const cloudItem = mergedMap.get(localItem.manga.id);
          if (!cloudItem) {
            mergedMap.set(localItem.manga.id, localItem);
          } else {
            const localDate = new Date(localItem.viewedAt).getTime();
            const cloudDate = new Date(cloudItem.viewedAt).getTime();

            if (localDate > cloudDate) {
              mergedMap.set(localItem.manga.id, localItem);
              console.log(
                `[Storage] Conflict resolved: Keeping LOCAL for ${localItem.manga.title} (Newer)`,
              );
            }
          }
        });

        const mergedHistory = Array.from(mergedMap.values())
          .sort(
            (a, b) =>
              new Date(b.viewedAt).getTime() - new Date(a.viewedAt).getTime(),
          )
          .slice(0, HISTORY_LIMIT_LOCAL);

        setLocal(STORAGE_KEYS.HISTORY, mergedHistory);
        setLastSynced('history', Date.now());
        setSyncStatus('history', 'idle');
        return mergedHistory;
      }

      setSyncStatus('history', 'idle');
      return getLocal<ViewedManga[]>(STORAGE_KEYS.HISTORY, []);
    } catch (e) {
      logError('[Storage] Failed to sync history:', e);
      setSyncStatus('history', 'error');
      return getLocal<ViewedManga[]>(STORAGE_KEYS.HISTORY, []);
    }
  },

  async getHistory(
    forceRefresh: boolean = false,
  ): Promise<StorageResult<ViewedManga[]>> {
    const local = getLocal<ViewedManga[]>(STORAGE_KEYS.HISTORY, []);
    const status = getSyncStatus('history');

    if (forceRefresh || status === 'idle') {
      const release = await acquireWriteLock('history');
      try {
        await this.syncHistory();
      } finally {
        release();
      }
    } else {
      this.syncHistory();
    }

    return {
      data: getLocal<ViewedManga[]>(STORAGE_KEYS.HISTORY, []),
      status: getSyncStatus('history'),
      lastSyncedAt: getLastSynced('history'),
    };
  },

  async addToHistory(
    manga: Manga,
    chapterId?: string,
    chapterTitle?: string,
  ): Promise<void> {
    const release = await acquireWriteLock('history');
    try {
      let history = getLocal<ViewedManga[]>(STORAGE_KEYS.HISTORY, []);
      history = history.filter((h) => h.manga.id !== manga.id);
      history.unshift({
        manga,
        lastChapterId: chapterId,
        lastChapterTitle: chapterTitle,
        viewedAt: new Date().toISOString(),
      });
      setLocal(STORAGE_KEYS.HISTORY, history.slice(0, HISTORY_LIMIT_LOCAL));

      await SyncEngine.enqueue({
        type: 'UPSERT',
        table: 'history',
        payload: {
          device_id: this.getDeviceId(),
          manga_id: manga.id,
          manga_data: manga,
          last_chapter_id: chapterId,
          last_chapter_title: chapterTitle,
          viewed_at: new Date().toISOString(),
        },
        timestamp: Date.now(),
      });
    } finally {
      release();
    }
  },

  async clearHistory(): Promise<void> {
    const release = await acquireWriteLock('history');
    try {
      const deviceId = this.getDeviceId();
      setLocal(STORAGE_KEYS.HISTORY, []);

      await SyncEngine.enqueue({
        type: 'DELETE',
        table: 'history',
        payload: { device_id: deviceId },
        timestamp: Date.now(),
      });
    } finally {
      release();
    }
  },

  // ============ SETTINGS ============

  async syncSettings(): Promise<AppSettings> {
    const deviceId = this.getDeviceId();
    setSyncStatus('settings', 'syncing');

    try {
      const cloudData = await SupabaseService.getAll<any>(
        'settings',
        `?select=dark_mode,dev_mode,scroll_speed&device_id=eq.${deviceId}`,
      );
      if (cloudData && cloudData.length > 0) {
        const row = cloudData[0];
        const settings: AppSettings = {
          darkMode: row.dark_mode ?? DEFAULT_SETTINGS.darkMode,
          devMode: row.dev_mode ?? DEFAULT_SETTINGS.devMode,
          scrollSpeed: row.scroll_speed ?? DEFAULT_SETTINGS.scrollSpeed,
        };
        setLocal(STORAGE_KEYS.SETTINGS, settings);
        setLastSynced('settings', Date.now());
        setSyncStatus('settings', 'idle');
        return settings;
      }

      setSyncStatus('settings', 'idle');
      return getLocal<AppSettings>(STORAGE_KEYS.SETTINGS, DEFAULT_SETTINGS);
    } catch (e) {
      logError('[Storage] Failed to sync settings:', e);
      setSyncStatus('settings', 'error');
      return getLocal<AppSettings>(STORAGE_KEYS.SETTINGS, DEFAULT_SETTINGS);
    }
  },

  async getSettings(): Promise<StorageResult<AppSettings>> {
    const local = getLocal<AppSettings>(
      STORAGE_KEYS.SETTINGS,
      DEFAULT_SETTINGS,
    );
    const status = getSyncStatus('settings');

    if (status === 'idle') {
      const release = await acquireWriteLock('settings');
      try {
        await this.syncSettings();
      } finally {
        release();
      }
    } else {
      this.syncSettings();
    }

    return {
      data: getLocal<AppSettings>(STORAGE_KEYS.SETTINGS, DEFAULT_SETTINGS),
      status: getSyncStatus('settings'),
      lastSyncedAt: getLastSynced('settings'),
    };
  },

  async saveSettings(settings: Partial<AppSettings>): Promise<void> {
    const release = await acquireWriteLock('settings');
    try {
      const current = getLocal<AppSettings>(
        STORAGE_KEYS.SETTINGS,
        DEFAULT_SETTINGS,
      );
      const updated = { ...current, ...settings };
      setLocal(STORAGE_KEYS.SETTINGS, updated);

      await SyncEngine.enqueue({
        type: 'UPSERT',
        table: 'settings',
        payload: {
          device_id: this.getDeviceId(),
          dark_mode: updated.darkMode,
          dev_mode: updated.devMode,
          scroll_speed: updated.scrollSpeed,
          updated_at: new Date().toISOString(),
        },
        timestamp: Date.now(),
      });
    } finally {
      release();
    }
  },

  getSettingsSync(): AppSettings {
    return getLocal<AppSettings>(STORAGE_KEYS.SETTINGS, DEFAULT_SETTINGS);
  },

  // ============ FILTERS ============

  getLastFilters(): SearchFilters | null {
    return getLocal<SearchFilters | null>(STORAGE_KEYS.FILTERS, null);
  },

  saveFilters(filters: SearchFilters): void {
    setLocal(STORAGE_KEYS.FILTERS, filters);
  },

  clearFilters(): void {
    memoryStorage.delete(STORAGE_KEYS.FILTERS);
    setNativeItem(STORAGE_KEYS.FILTERS, '');
  },

  // ============ READER POSITION ============

  saveReaderPosition(
    mangaId: string,
    chapterUrl: string,
    panelIndex: number,
    scrollPosition?: number,
  ): void {
    const deviceId = this.getDeviceId();
    const position: ReaderPosition = {
      mangaId,
      chapterUrl,
      panelIndex,
      scrollPosition,
      timestamp: new Date().toISOString(),
    };
    console.log(
      `[Storage] Saving reader position: manga=${mangaId}, panel=${panelIndex}, device=${deviceId}`,
    );
    setLocal(STORAGE_KEYS.READER_POSITION, position);

    (async () => {
      await SyncEngine.enqueue({
        type: 'UPSERT',
        table: 'reader_positions',
        payload: {
          device_id: deviceId,
          manga_id: mangaId,
          chapter_url: chapterUrl,
          panel_index: panelIndex,
          updated_at: position.timestamp,
        },
        timestamp: Date.now(),
      });
    })();
  },

  async getReaderPositionForManga(
    mangaId: string,
  ): Promise<ReaderPosition | null> {
    const local = this.getReaderPosition();
    if (local && local.mangaId === mangaId) return local;

    try {
      const deviceId = this.getDeviceId();
      const data = await SupabaseService.getAll<any>(
        'reader_positions',
        `?select=chapter_url,panel_index,updated_at&device_id=eq.${deviceId}&manga_id=eq.${mangaId}&limit=1`,
      );

      if (data && data.length > 0) {
        const row = data[0];
        return {
          mangaId,
          chapterUrl: row.chapter_url,
          panelIndex: Number(row.panel_index),
          timestamp: row.updated_at,
        };
      }
    } catch (e) {
      logError('[Storage] Failed to fetch reader position from cloud:', e);
    }

    return null;
  },

  getReaderPosition(): ReaderPosition | null {
    return getLocal<ReaderPosition | null>(STORAGE_KEYS.READER_POSITION, null);
  },

  clearReaderPosition(): void {
    memoryStorage.delete(STORAGE_KEYS.READER_POSITION);
    setNativeItem(STORAGE_KEYS.READER_POSITION, '');
  },

  // ============ UPDATE SKIP / ATTEMPT ============

  getSkippedVersion(): string | null {
    return getLocal<string | null>(STORAGE_KEYS.SKIPPED_VERSION, null);
  },

  setSkippedVersion(version: string): void {
    setLocal(STORAGE_KEYS.SKIPPED_VERSION, version);
  },

  getLastUpdateAttempt(): string | null {
    return getLocal<string | null>(STORAGE_KEYS.UPDATE_ATTEMPT, null);
  },

  async setLastUpdateAttempt(hash: string): Promise<void> {
    await setLocal(STORAGE_KEYS.UPDATE_ATTEMPT, hash);
  },

  clearLastUpdateAttempt(): void {
    memoryStorage.delete(STORAGE_KEYS.UPDATE_ATTEMPT);
    setNativeItem(STORAGE_KEYS.UPDATE_ATTEMPT, '');
  },

  // ============ CLEAR ALL ============

  async clearAllData(): Promise<void> {
    try {
      const deviceId = this.getDeviceId();
      memoryStorage.clear();
      await this.clearHistory();

      await SyncEngine.enqueue({
        type: 'DELETE',
        table: 'favorites',
        payload: { device_id: deviceId },
        timestamp: Date.now(),
      });
    } catch (e) {
      logWarn('[Storage] clearAllData failed:', e);
    }
  },

  // ============ NATIVE ACCESSORS ============

  // ============ DEBUG & INSPECTOR ============

  getMemoryState(): Record<string, any> {
    const state: Record<string, any> = {};
    for (const [key, val] of memoryStorage.entries()) {
      try {
        state[key] = JSON.parse(val);
      } catch {
        state[key] = val;
      }
    }
    return state;
  },

  async clearKey(key: string): Promise<void> {
    memoryStorage.delete(key);
    setNativeItem(key, '');
    logWarn('[Storage] Cleared key via inspector:', key);
  },

  async getNativeItemSync(key: string): Promise<string | null> {
    return await getNativeItem(key);
  },

  setNativeItemSync(key: string, value: string): void {
    setNativeItem(key, value);
  },

  /**
   * Check if a new chapter is available by comparing the latest chapter URL.
   * This is independent of the user's reading progress.
   */
  checkForUpdates(localManga: Manga, remoteManga: Manga): boolean {
    // 1. Prefer ID-based comparison (Robuster)
    if (localManga.latestChapterId && remoteManga.latestChapterId) {
      if (localManga.latestChapterId !== remoteManga.latestChapterId) {
        log(
          `[Storage] Update detected via ID: Local=${localManga.latestChapterId} vs Remote=${remoteManga.latestChapterId}`,
        );
        return true;
      }
      return false;
    }

    // 2. Fallback to URL-based comparison
    // If remote has no info, we can't confirm an update
    if (!remoteManga.latestChapterUrl) {
      return false;
    }

    // If local has no info (legacy data) but remote does, assume it's new
    if (!localManga.latestChapterUrl) {
      log(
        '[Storage] Update assumed (Legacy local data missing latestChapterUrl)',
      );
      return true;
    }

    // Normalize function to handle trailing slashes or protocol diffs if needed
    const normalize = (u: string) => u.replace(/\/+$/, '').toLowerCase().trim();

    const local = normalize(localManga.latestChapterUrl);
    const remote = normalize(remoteManga.latestChapterUrl);

    if (local !== remote) {
      log(
        `[Storage] Update detected via URL: Local=${local} vs Remote=${remote}`,
      );
      return true;
    }

    return false;
  },

  /**
   * Check for updates on user's favorites.
   * force = true bypasses the 1-hour throttle.
   */
  async checkFavoritesForUpdates(
    force: boolean = false,
  ): Promise<Map<string, Manga>> {
    try {
      const settingsResult = await this.getSettings();
      const settings = settingsResult.data;
      log(
        `[Storage] checkFavoritesForUpdates. Force=${force}, Mock=${!!settings.mockUpdates}`,
      );

      if (settings.mockUpdates) {
        log(
          '[Storage] Mock Updates ENABLED - Forcing updates on history items',
        );
        const mockMap = new Map<string, Manga>();
        const historyResult = await this.getHistory();
        const currentHistory = historyResult.data;

        currentHistory.forEach((item) => {
          const mockManga = { ...item.manga };
          mockManga.latestChapterUrl =
            (item.manga.latestChapterUrl || '') + '_mock_update';
          mockManga.latestChapter =
            'NEW ' + (item.manga.latestChapter || 'Chapter');
          mockMap.set(item.manga.id, mockManga);
        });

        return mockMap;
      }

      // Check throttle if not forced
      const LAST_CHECK_KEY = 'batoto:last_update_check';
      const CACHED_UPDATES_KEY = 'batoto:cached_updates';
      const ONE_HOUR = 60 * 60 * 1000;

      const now = Date.now();

      if (!force) {
        const lastCheckStr = await getNativeItemSync(LAST_CHECK_KEY);
        const lastCheck = lastCheckStr ? parseInt(lastCheckStr, 10) : 0;
        const shouldCheck = now - lastCheck > ONE_HOUR;

        if (!shouldCheck) {
          log(
            `[Storage] Throttled update check (Last: ${new Date(lastCheck).toLocaleTimeString()}). Loading cache.`,
          );
          const cachedStr = await getNativeItemSync(CACHED_UPDATES_KEY);
          if (cachedStr) {
            try {
              const cachedList: Manga[] = JSON.parse(cachedStr);
              const map = new Map<string, Manga>();
              cachedList.forEach((m) => map.set(m.id, m));
              return map;
            } catch (e) {
              logError('[Storage] Failed to parse cached updates:', e);
            }
          }
          return new Map();
        }
      }

      // NOTE: Batoto is removed, avoiding batch fetch for now.
      const updates: Manga[] = [];
      log(`[Storage] Fetched updates for ${updates.length} favorites`);

      const updateMap = new Map<string, Manga>();
      updates.forEach((m) => updateMap.set(m.id, m));

      // Save Cache
      setNativeItemSync(CACHED_UPDATES_KEY, JSON.stringify(updates));
      setNativeItemSync(LAST_CHECK_KEY, now.toString());

      return updateMap;
    } catch (e) {
      logError('[Storage] Failed to check for updates:', e);
      return new Map();
    }
  },

  // Trigger debug capture for debugging stuck loading states
  async triggerDebugCapture(): Promise<void> {
    log('[Storage] AUTO-CAPTURE: Triggering debug report capture');
    try {
      const { DebugLogService } = await import('./debugLog');
      const { SupabaseService } = await import('./supabase');
      const settingsResult = await this.getSettings();
      const settings = settingsResult.data;
      const deviceId = this.getDeviceId();

      const storageValues: Record<string, any> = {};
      const keysToCapture = [
        STORAGE_KEYS.FAVORITES,
        STORAGE_KEYS.HISTORY,
        STORAGE_KEYS.SETTINGS,
        STORAGE_KEYS.FILTERS,
      ];

      for (const key of keysToCapture) {
        try {
          const value = getLocal(key, null);
          if (value !== null) {
            storageValues[key] = JSON.stringify(value).substring(0, 500); // Truncate
          }
        } catch (e) {
          storageValues[key] = '<error>';
        }
      }

      const structuredReport = {
        app_version: '1.0.250',
        environment_info: { deviceId, platform: 'Lynx' },
        settings,
        storage_state: storageValues,
        console_logs: [],
        supabase_status: { status: 'Auto-capture' },
      };

      const debugReport = DebugLogService.getDebugReport(structuredReport);

      // Use upsert like DeveloperOptions does
      await SupabaseService.upsert(
        'debug_logs',
        {
          device_id: deviceId,
          report: debugReport,
          app_version: structuredReport.app_version,
          environment_info: structuredReport.environment_info,
          settings: structuredReport.settings,
          supabase_status: structuredReport.supabase_status,
          storage_state: structuredReport.storage_state,
          console_logs: structuredReport.console_logs,
          created_at: new Date().toISOString(),
        },
        'device_id',
      );

      log('[Storage] AUTO-CAPTURE: Debug report sent successfully');
    } catch (e) {
      logError('[Storage] AUTO-CAPTURE: Failed to capture debug report:', e);
    }
  },
};

// Export initialization promise so other modules can wait
export const storageReady = (async () => {
  try {
    // 1. Core Native Init
    await initializeFromNativeStorage();

    // 2. Data Migration (Legacy -> Cloud)
    await MigrationService.run();

    // 3. Initial Cloud Sync
    await StorageService.getSettings();

    log('[Storage] System is READY');
  } catch (e: any) {
    logError(
      '[Storage] Initialization sequence failed:',
      e?.message || e?.toString?.() || JSON.stringify(e) || e,
    );
  }
})();


--------------------------------

FILE: services/supabase.ts
SIZE: 4.40 KB
TYPE: ts

CONTENT:
// Supabase REST Client
// Bypasses the official client to avoid WebSocket/Runtime issues in Lynx

import { SUPABASE_ANON_KEY, SUPABASE_REST_URL } from '../config';
import { StorageService } from './storage';

const HEADERS = {
  apikey: SUPABASE_ANON_KEY,
  Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
  'Content-Type': 'application/json',
  Prefer: 'return=minimal', // Don't return the inserted row to save data
};

export const SupabaseService = {
  /**
   * Generic Fetch Wrapper
   */
  async request<T>(
    endpoint: string,
    options: RequestInit = {},
  ): Promise<T | null> {
    try {
      if (typeof fetch === 'undefined') {
        // console.warn('[Supabase] fetch is not defined in this environment. Skipping request.');
        return null;
      }

      const response = await fetch(`${SUPABASE_REST_URL}${endpoint}`, {
        ...options,
        headers: {
          ...HEADERS,
          ...options.headers,
        },
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error(
          `[Supabase] Request failed: ${response.status} ${response.statusText}`,
          errorText,
          `Endpoint: ${endpoint}`,
          `Body: ${options.body}`,
        );
        return null;
      }

      // If no content (204), return true to indicate success but no data
      if (response.status === 204) {
        return true as any;
      }

      // Safe JSON parsing for handling empty bodies (even if not 204)
      const text = await response.text();
      if (!text || text.trim().length === 0) {
        return null;
      }

      try {
        return JSON.parse(text);
      } catch (e) {
        console.warn('[Supabase] Failed to parse JSON response:', text);
        return null;
      }
    } catch (e) {
      console.warn('[Supabase] Network error:', e);
      return null;
    }
  },

  /**
   * Get all rows from a table
   */
  async getAll<T>(table: string, queryParams: string = ''): Promise<T[]> {
    // Example: ?select=*&order=created_at.desc
    const result = await this.request<T[]>(`/${table}${queryParams}`);
    return result || [];
  },

  /**
   * Upsert a row (Insert or Update)
   */
  async upsert(
    table: string,
    data: any,
    conflictColumn: string = 'id',
  ): Promise<boolean> {
    // resolution=merge-duplicates is key for upsert behavior via REST
    // Use return=representation to distinguish 204 vs error
    const headers = {
      Prefer: `resolution=merge-duplicates,return=representation`,
    };

    const result = await this.request(
      `/${table}?on_conflict=${conflictColumn}`,
      {
        method: 'POST',
        headers,
        body: JSON.stringify(data),
      },
    );

    return result !== null;
  },

  /**
   * Delete rows matching a condition
   * @param value - Can be a raw value (implies 'eq.') or an operator string like 'neq.0'
   */
  async delete(table: string, column: string, value: string): Promise<boolean> {
    const filter = value.match(
      /^(eq\.|neq\.|gt\.|gte\.|lt\.|lte\.|like\.|ilike\.|is\.|in\.|cs\.|cd\.|ov\.|sl\.|sr\.|nxr\.|nxl\.|adj\.)/,
    )
      ? value
      : `eq.${value}`;

    // Use return=representation to distinguish 204 vs error
    const headers = {
      Prefer: `return=representation`,
    };

    const result = await this.request(`/${table}?${column}=${filter}`, {
      method: 'DELETE',
      headers,
    });

    return result !== null;
  },

  /**
   * Get a global config value by key from 'app_config' table
   */
  async getGlobalConfig(key: string): Promise<string | null> {
    try {
      // Expects table "app_config" with columns "key", "value"
      const data = await this.getAll<{ value: string }>(
        'app_config',
        `?select=value&key=eq.${key}&limit=1`,
      );
      if (data && data.length > 0) {
        return data[0].value;
      }
      return null;
    } catch (e) {
      console.warn(`[Supabase] Failed to fetch config for ${key}`, e);
      return null;
    }
  },

  /**
   * Insert a debug report into debug_logs table
   */
  async captureDebugReport(report: string): Promise<boolean> {
    try {
      const deviceId = StorageService?.getDeviceId?.() || 'unknown';
      const data = {
        device_id: deviceId,
        report: report,
        app_version: '1.0.245',
      };
      return await this.upsert('debug_logs', data, 'id');
    } catch (e) {
      console.warn('[Supabase] Failed to capture debug report', e);
      return false;
    }
  },
};


--------------------------------

FILE: services/sync.ts
SIZE: 6.43 KB
TYPE: ts

CONTENT:
import { SYNC_HEARTBEAT_INTERVAL_MS } from '../config';
import { getNativeItemSync, setNativeItemSync } from './nativeStorage';
import { PerformanceService } from './perf';
import { SupabaseService } from './supabase';

export type OperationType = 'UPSERT' | 'DELETE';

export interface Operation {
  type: OperationType;
  table: string;
  payload: any;
  timestamp: number;
}

const QUEUE_STORAGE_KEY = 'batoto:sync_queue';
let isSyncing = false;

/**
 * Background Sync Engine & Operation Queue
 */
export const SyncEngine = {
  listeners: new Set<() => void>(),

  subscribe(listener: () => void): () => void {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  },

  notify() {
    this.listeners.forEach((l) => l());
  },

  isSyncing(): boolean {
    return isSyncing;
  },

  /**
   * Add an operation to the persistent queue
   */
  async enqueue(op: Operation): Promise<void> {
    console.log(
      `[SyncEngine] Enqueueing ${op.type} for ${op.table}:`,
      JSON.stringify(op.payload).substring(0, 200),
    );
    const queue = await this.getQueue();
    queue.push(op);
    await this.saveQueue(queue);
    console.log(`[SyncEngine] Queue size after enqueue: ${queue.length}`);
    this.notify();

    // Trigger background sync attempt
    this.processQueue();
  },

  /**
   * Process the pending operations in the queue
   */
  async processQueue(): Promise<void> {
    if (isSyncing) {
      console.log('[SyncEngine] Already syncing, skipping...');
      return;
    }

    const queue = await this.getQueue();
    if (queue.length === 0) {
      console.log('[SyncEngine] Queue is empty, nothing to process');
      return;
    }

    console.log(`[SyncEngine] Processing queue (${queue.length} items)...`);
    isSyncing = true;
    this.notify();

    PerformanceService.startTimer('SyncEngine.processQueue');

    try {
      // Processes operations sequentially to maintain order and validity
      while (queue.length > 0) {
        const op = queue[0];
        console.log(`[SyncEngine] Executing: ${op.type} on ${op.table}...`);
        const success = await this.executeOperation(op);

        if (success) {
          console.log(`[SyncEngine] SUCCESS: ${op.type} on ${op.table}`);
          queue.shift(); // Remove processed
          await this.saveQueue(queue);
          this.notify();
        } else {
          // If execution fails (e.g., network error), stop and retry later
          console.warn(
            '[SyncEngine] Operation failed, stopping queue processing',
          );
          break;
        }
      }
    } catch (e: any) {
      console.error(
        '[SyncEngine] Critical error during queue processing:',
        e?.message || e,
      );
    } finally {
      PerformanceService.endTimer('SyncEngine.processQueue');
      isSyncing = false;
      this.notify();
      console.log(
        `[SyncEngine] Finished processing. Remaining: ${queue.length}`,
      );
    }
  },

  /**
   * Internal executor for Supabase operations
   */
  async executeOperation(op: Operation): Promise<boolean> {
    try {
      if (op.type === 'UPSERT') {
        // Find conflict column based on table
        let conflictColumn = 'id';
        if (op.table === 'settings') conflictColumn = 'device_id';
        if (
          op.table === 'favorites' ||
          op.table === 'history' ||
          op.table === 'reader_positions'
        ) {
          conflictColumn = 'device_id,manga_id';
        }

        const success = await SupabaseService.upsert(
          op.table,
          op.payload,
          conflictColumn,
        );
        return success;
      } else if (op.type === 'DELETE') {
        const deviceId = op.payload.device_id;
        const column = op.table === 'settings' ? 'device_id' : 'manga_id';
        const value = op.table === 'settings' ? deviceId : op.payload.manga_id;

        // For table-specific deletes (favorites/history), we usually need both ID filters
        // but our current SupabaseService.delete is a bit simplified.
        // If it's a many-to-many style table, we need complex filters.
        if (op.table === 'favorites' || op.table === 'history') {
          const success = await SupabaseService.request(
            `/${op.table}?device_id=eq.${deviceId}&manga_id=eq.${op.payload.manga_id}`,
            {
              method: 'DELETE',
              // Ensure we get a response body to confirm success vs error
              headers: { Prefer: 'return=representation' },
            },
          );
          return success !== null;
        }

        const success = await SupabaseService.delete(op.table, column, value);
        return success;
      }
      return true;
    } catch (e) {
      console.error('[SyncEngine] Execution failed:', e);
      return false;
    }
  },

  /**
   * Persistent storage access
   */
  async getQueue(): Promise<Operation[]> {
    const raw = await getNativeItemSync(QUEUE_STORAGE_KEY);
    if (!raw) return [];
    try {
      // Zombie Check: If raw string is massive, we might have a corrupt or clogged queue
      if (raw.length > 500000) {
        // 500kb safety limit
        console.warn(
          '[SyncEngine] ZOMBIE QUEUE DETECTED (Size > 500kb). PURGING QUEUE TO RESTORE SYNC.',
        );
        await this.saveQueue([]);
        return [];
      }

      const queue = JSON.parse(raw);

      // Secondary safety check for item count
      if (Array.isArray(queue) && queue.length > 500) {
        console.warn(
          '[SyncEngine] ZOMBIE QUEUE DETECTED (Count > 500). PURGING QUEUE TO RESTORE SYNC.',
        );
        await this.saveQueue([]);
        return [];
      }

      return queue;
    } catch {
      return [];
    }
  },

  async saveQueue(queue: Operation[]): Promise<void> {
    await setNativeItemSync(QUEUE_STORAGE_KEY, JSON.stringify(queue));
  },

  /**
   * Get a set of IDs that are pending deletion in the queue
   */
  async getPendingDeletions(table: string): Promise<Set<string>> {
    const queue = await this.getQueue();
    const deletions = new Set<string>();
    queue.forEach((op) => {
      if (op.type === 'DELETE' && op.table === table && op.payload.manga_id) {
        deletions.add(op.payload.manga_id);
      }
    });
    return deletions;
  },
};

// Initialize network heartbeat for background sync
if (typeof lynx !== 'undefined' || typeof globalThis !== 'undefined') {
  // Attempt sync at configured interval if queue is not empty
  setInterval(() => {
    SyncEngine.processQueue();
  }, SYNC_HEARTBEAT_INTERVAL_MS);
}


--------------------------------

FILE: services/update.ts
SIZE: 10.51 KB
TYPE: ts

CONTENT:
import {
  DEFAULT_OTA_BUNDLE_URL,
  STORAGE_INIT_TIMEOUT_MS,
  UPDATE_CHECK_COOLDOWN_MS,
} from '../config';
import { logCapture } from './debugLog';
import { StorageService, storageReady } from './storage';
import { SupabaseService } from './supabase';

let storageInitialized = false;
let resolveStorageReady: () => void;
const storageReadyPromise = new Promise<void>((resolve) => {
  resolveStorageReady = resolve;
});

function markStorageReady() {
  if (storageInitialized) return;
  log('[UpdateService] Storage ready marked');
  storageInitialized = true;
  resolveStorageReady();
}

// Wait for global storage to be ready
storageReady.then(() => {
  log('[UpdateService] Global storage ready signal received');
  markStorageReady();
});

// Safety timeout: don't wait for storage more than configured time
setTimeout(() => {
  if (!storageInitialized) {
    console.warn('[UpdateService] Storage init timed out, proceeding anyway');
    markStorageReady();
  }
}, STORAGE_INIT_TIMEOUT_MS);

const log = (...args: any[]) => logCapture('log', ...args);
const logWarn = (...args: any[]) => logCapture('warn', ...args);
const logError = (...args: any[]) => logCapture('error', ...args);

export interface AppUpdate {
  version: string;
  commitHash?: string;
  isMandatory: boolean;
  releaseNotes: string;
  forceImmediate: boolean;
  otaUrl?: string; // URL to the new lynx bundle
}

// Cooldown state for navigation-based checks
let lastCheckTimestamp = 0;

export interface NativeAppUpdate {
  version: string;
  url: string;
  isMandatory: boolean;
  releaseNotes: string;
  forceImmediate: boolean;
  commitHash?: string;
}

export const BUNDLE_VERSION = '1.0.258';
export const BUNDLE_COMMIT_HASH = 'd88e202'; // Will be injected by publish-ota.js

export const UpdateService = {
  /**
   * Fetch the latest update entry from Supabase
   */
  async getLatestUpdate(): Promise<AppUpdate | null> {
    try {
      const data = await SupabaseService.getAll<any>(
        'app_updates',
        '?select=version,commit_hash,is_mandatory,force_immediate,release_notes,download_url&order=created_at.desc&limit=1',
      );

      if (data && data.length > 0) {
        const row = data[0];
        return {
          version: row.version,
          commitHash: row.commit_hash || '',
          isMandatory: !!row.is_mandatory || !!row.force_immediate,
          releaseNotes: row.release_notes || '',
          forceImmediate: !!row.force_immediate,
          otaUrl:
            row.download_url ||
            'https://raw.githubusercontent.com/CodingInCarhartts/SMUTHUB/main/main.lynx.bundle',
        };
      }
    } catch (e) {
      logWarn('[UpdateService] Failed to fetch updates:', e);
    }
    return null;
  },

  /**
   * Compare two semver strings
   * Returns:
   *   1 if v1 > v2
   *  -1 if v1 < v2
   *   0 if v1 == v2
   */
  compareVersions(v1: string, v2: string): number {
    const parts1 = v1.split('.').map((p) => parseInt(p, 10) || 0);
    const parts2 = v2.split('.').map((p) => parseInt(p, 10) || 0);

    const length = Math.max(parts1.length, parts2.length);
    for (let i = 0; i < length; i++) {
      const p1 = parts1[i] || 0;
      const p2 = parts2[i] || 0;
      if (p1 > p2) return 1;
      if (p1 < p2) return -1;
    }
    return 0;
  },

  /**
   * Check if a newer version exists and hasn't been skipped.
   * Includes a cooldown to prevent spamming server during rapid navigation.
   */
  async checkUpdate(): Promise<AppUpdate | null> {
    // Wait for storage to be ready (so we have the skipped version)
    await storageReadyPromise;
    log('[UpdateService] Starting update check...');

    const now = Date.now();
    if (now - lastCheckTimestamp < UPDATE_CHECK_COOLDOWN_MS) {
      log(
        `[UpdateService] Skipping check (cooldown active: ${Math.round((UPDATE_CHECK_COOLDOWN_MS - (now - lastCheckTimestamp)) / 1000)}s left).`,
      );
      return null;
    }
    lastCheckTimestamp = now;

    log('[UpdateService] Fetching from Supabase (app_updates)...');
    const latest = await this.getLatestUpdate();
    if (!latest) {
      log('[UpdateService] No update data found in Supabase');
      return null;
    }
    log(
      `[UpdateService] Latest in DB: ${latest.version} (hash: ${latest.commitHash})`,
    );

    // LOOP PROTECTION:
    // If we just attempted this update (based on last_update_attempt)
    // AND our BUNDLE_COMMIT_HASH is still different (update didn't take),
    // then assume we downloaded a stale bundle and STOP.
    const lastAttempt = StorageService.getLastUpdateAttempt();
    if (
      lastAttempt &&
      lastAttempt === latest.commitHash &&
      latest.commitHash !== BUNDLE_COMMIT_HASH
    ) {
      console.warn(
        `[UpdateService] LOOP DETECTED! We already attempted update to ${lastAttempt} but are still on ${BUNDLE_COMMIT_HASH}. Aborting.`,
      );
      // Optional: Clear it if we want to retry later? No, wait for next version.
      // But if user manually forces via "Check Update" button, we might want to bypass?
      // For auto-check, definitely block.
      return null;
    }

    // If we are here, it means either:
    // 1. We haven't tried this update yet.
    // 2. We DID try it, and it SUCCEEDED (so BUNDLE matches LastAttempt).
    //    In case 2, we shouldn't be here if check below passes.

    // If successfully updated, clear the flag
    if (BUNDLE_COMMIT_HASH === lastAttempt) {
      StorageService.clearLastUpdateAttempt();
    }

    // Check if commit hash matches (primary check)
    if (latest.commitHash && latest.commitHash === BUNDLE_COMMIT_HASH) {
      log('[UpdateService] Commit hash matches. App is up to date.');
      return null;
    }

    // Check if version/hash is skipped
    const skipped = StorageService.getSkippedVersion();
    if (
      (skipped === latest.commitHash || skipped === latest.version) &&
      !latest.isMandatory
    ) {
      log(`[UpdateService] Version ${latest.version} is skipped by user.`);
      return null;
    }

    // If commit hash differs, there's an update
    if (latest.commitHash && latest.commitHash !== BUNDLE_COMMIT_HASH) {
      log(
        `[UpdateService] NEW UPDATE FOUND! Hash mismatch: ${latest.commitHash} vs ${BUNDLE_COMMIT_HASH}`,
      );
      return latest;
    }

    // Fallback to semver comparison for legacy entries without commit_hash
    const comparison = this.compareVersions(latest.version, BUNDLE_VERSION);
    log(
      `[UpdateService] Fallback semver compare: ${latest.version} vs ${BUNDLE_VERSION} => Result: ${comparison}`,
    );

    if (comparison > 0) {
      log('[UpdateService] NEW UPDATE FOUND (via semver fallback)!');
      return latest;
    }

    log('[UpdateService] App is up to date.');
    return null;
  },

  /**
   * Mark a version as skipped
   */
  skipVersion(version: string): void {
    log(`[UpdateService] Skipping version ${version}`);
    StorageService.setSkippedVersion(version);
  },

  /**
   * Check if a newer native APK version exists in Supabase
   */
  async checkNativeUpdate(): Promise<NativeAppUpdate | null> {
    try {
      const nativeUpdater =
        typeof NativeModules !== 'undefined'
          ? NativeModules.NativeUpdaterModule
          : null;
      if (!nativeUpdater) return null;

      const currentVersion = nativeUpdater.getNativeVersion();

      const data = await SupabaseService.getAll<any>(
        'app_native_updates',
        '?select=version,download_url,is_mandatory,force_immediate,release_notes&order=created_at.desc&limit=1',
      );

      if (data && data.length > 0) {
        const latest = data[0];
        if (this.compareVersions(latest.version, currentVersion) > 0) {
          log(
            `[UpdateService] New native APK found: ${latest.version} (URL: ${latest.download_url})`,
          );
          return {
            version: latest.version,
            url: latest.download_url,
            isMandatory: !!latest.is_mandatory || !!latest.force_immediate,
            releaseNotes:
              latest.release_notes ||
              'New native features and performance improvements.',
            forceImmediate: !!latest.force_immediate,
          };
        }
      }
    } catch (e) {
      logWarn('[UpdateService] Native update check failed:', e);
    }
    return null;
  },

  /**
   * Trigger the native APK installation flow
   */
  async installNativeUpdate(url: string): Promise<void> {
    log('[UpdateService] Triggering native APK install from:', url);
    const nativeUpdater =
      typeof NativeModules !== 'undefined'
        ? NativeModules.NativeUpdaterModule
        : null;
    if (nativeUpdater && nativeUpdater.installUpdate) {
      try {
        nativeUpdater.installUpdate(url);
      } catch (e) {
        logError('[UpdateService] Failed to trigger native update:', e);
      }
    } else {
      logError('[UpdateService] NativeUpdaterModule not available');
    }
  },

  /**
   * Exit the app immediately
   */
  exitApp(): void {
    log('[UpdateService] Exiting app...');
    try {
      const utils =
        typeof NativeModules !== 'undefined'
          ? NativeModules.NativeUtilsModule
          : null;
      if (utils && utils.exitApp) {
        utils.exitApp();
      } else {
        logWarn('[UpdateService] exitApp not available');
      }
    } catch (e) {
      logError('[UpdateService] Failed to exit app:', e);
    }
  },

  /**
   * Reload the Lynx bundle to apply the OTA update
   */
  async applyUpdate(update?: AppUpdate): Promise<void> {
    log('[UpdateService] Applying update...');
    try {
      const nativeUpdater =
        typeof NativeModules !== 'undefined'
          ? NativeModules.NativeUpdaterModule
          : null;

      if (update?.otaUrl && nativeUpdater && (nativeUpdater as any).setOtaUrl) {
        log(`[UpdateService] Setting remote OTA URL: ${update.otaUrl}`);

        // LOOP PROTECTION: Mark this hash as attempted
        if (update.commitHash) {
          await StorageService.setLastUpdateAttempt(update.commitHash);
        }

        (nativeUpdater as any).setOtaUrl(update.otaUrl);

        if ((nativeUpdater as any).triggerOtaReload) {
          (nativeUpdater as any).triggerOtaReload();
          return;
        }
      }

      // Fallback to standard reload
      log('[UpdateService] Falling back to standard lynx.reload()');
      const runtime =
        typeof lynx !== 'undefined' ? lynx : (globalThis as any).lynx;
      if (runtime && runtime.reload) {
        runtime.reload();
      } else {
        logWarn(
          '[UpdateService] lynx.reload is not available, falling back to exitApp',
        );
        this.exitApp();
      }
    } catch (e) {
      logError('[UpdateService] Reload failed:', e);
    }
  },
};


--------------------------------

FILE: services/types.ts
SIZE: 2.92 KB
TYPE: ts

CONTENT:
export interface Manga {
  id: string;
  title: string;
  url: string;
  cover: string;
  genres?: string[];
  genreIds?: number[];
  latestChapter?: string;
  latestChapterUrl?: string; // URL of the latest chapter (for update checking)
  latestChapterId?: string; // ID of the latest chapter
  description?: string;
  authors?: string[];
  status?: string;
  rating?: string;
  views?: string;
  source?: string; // Source ID (e.g., 'batoto', 'mangago')
}

export interface Chapter {
  id: string;
  title: string;
  url: string;
  chapterNum?: string;
  volNum?: string;
  language?: string;
  group?: string;
  uploadDate?: string;
  source?: string;
}

export interface MangaDetails extends Manga {
  chapters: Chapter[];
  relatedSeries?: Manga[];
}

export interface Page {
  url: string;
  index: number;
}

export interface SearchFilters {
  genres: string[];
  status: 'all' | 'ongoing' | 'completed' | 'cancelled';
  sort: 'latest' | 'new' | 'az' | 'numc' | 'views_d030';
  nsfw: boolean;
  page?: number;
}

export interface MangaSource {
  name: string;
  id: string; // unique identifier e.g. 'batoto', 'mangago'
  baseUrl: string;
  isNsfwSource?: boolean;

  search(query: string, filters?: SearchFilters): Promise<Manga[]>;
  getMangaDetails(idOrUrl: string): Promise<MangaDetails | null>;
  getChapterPages(chapterIdOrUrl: string): Promise<string[]>;
  getHomeFeed(): Promise<{ popular: Manga[]; latest: Manga[] }>;
  getPopular?: () => Promise<Manga[]>;
  getLatest?: () => Promise<Manga[]>;
  headers?: Record<string, string>;
}

export const GENRE_API_MAPPING: Record<string, string> = {
  '4-Koma': '4-koma',
  Action: 'action',
  Adult: 'adult',
  Adventure: 'adventure',
  Artbook: 'artbook',
  'Award Winning': 'award-winning',
  Comedy: 'comedy',
  Cooking: 'cooking',
  Doujinshi: 'doujinshi',
  Drama: 'drama',
  Ecchi: 'ecchi',
  Fantasy: 'fantasy',
  'Gender Bender': 'gender-bender',
  Harem: 'harem',
  Historical: 'historical',
  Horror: 'horror',
  Isekai: 'isekai',
  Josei: 'josei',
  Loli: 'loli',
  Manhua: 'manhua',
  Manhwa: 'manhwa',
  'Martial Arts': 'martial-arts',
  Mecha: 'mecha',
  Medical: 'medical',
  Music: 'music',
  Mystery: 'mystery',
  'One Shot': 'one-shot',
  'Overpowered MC': 'overpowered-mc',
  Psychological: 'psychological',
  Reincarnation: 'reincarnation',
  Romance: 'romance',
  'School Life': 'school-life',
  'Sci-fi': 'sci-fi',
  Seinen: 'seinen',
  Shota: 'shota',
  Shoujo: 'shoujo',
  'Shoujo Ai': 'shoujo-ai',
  Shounen: 'shounen',
  'Shounen Ai': 'shounen-ai',
  'Slice of Life': 'slice-of-life',
  Sports: 'sports',
  'Super Power': 'super-power',
  Supernatural: 'supernatural',
  Survival: 'survival',
  'Time Travel': 'time-travel',
  Tragedy: 'tragedy',
  Webtoon: 'webtoon',
  Yaoi: 'yaoi',
  Yuri: 'yuri',
};

export const mapGenreToApi = (genre: string): string => {
  return (
    GENRE_API_MAPPING[genre] ||
    genre
      .toLowerCase()
      .replace(/\s+/g, '_')
      .replace(/[^a-z0-9_]/g, '')
  );
};


--------------------------------

FILE: services/sourceManager.ts
SIZE: 3.19 KB
TYPE: ts

CONTENT:
import { ComixService } from './comix';
import { MangagoService } from './mangago';
import { MangaparkService } from './mangapark';
import type { Manga, MangaDetails, MangaSource, SearchFilters } from './types';

class SourceManager {
  private sources: Map<string, MangaSource> = new Map();
  private defaultSource: string = 'comix';

  constructor() {
    // console.log('[SourceManager] Initializing...');
    // We will register sources here
    // this.registerSource(MangagoService); // KEEP DISABLED
    // this.registerSource(MangaparkService); // DISABLED FOR ISOLATION
    this.registerSource(ComixService);
    // console.log(`[SourceManager] Registry size: ${this.sources.size}`);
    // console.log(`[SourceManager] Keys: ${Array.from(this.sources.keys()).join(', ')}`);
  }

  getDefaultSource(): string {
    return this.defaultSource;
  }

  registerSource(source: MangaSource) {
    if (!source || !source.id) {
      console.error(
        '[SourceManager] Invalid source registration attempt',
        source,
      );
      return;
    }
    this.sources.set(source.id, source);
    console.log(`[SourceManager] Registered source: ${source.id}`);
  }

  getAvailableSources(): MangaSource[] {
    return Array.from(this.sources.values());
  }

  getSource(id: string): MangaSource | undefined {
    return this.sources.get(id);
  }

  // Helper to determine source from ID or URL
  resolveSource(idOrUrl: string): MangaSource | undefined {
    if (idOrUrl.startsWith('mangago:') || idOrUrl.includes('mangago.me')) {
      return this.sources.get('mangago');
    }

    if (
      idOrUrl.startsWith('mangapark:') ||
      idOrUrl.includes('mangapark.net') ||
      idOrUrl.includes('mangakatana.com')
    ) {
      return this.sources.get('mangapark');
    }

    if (idOrUrl.startsWith('comix:') || idOrUrl.includes('comix.to')) {
      return this.sources.get('comix');
    }

    // Fallback based on known prefixes if we implement namespacing
    const prefix = idOrUrl.split(':')[0];
    if (this.sources.has(prefix)) {
      return this.sources.get(prefix);
    }

    return this.sources.get(this.defaultSource);
  }

  async search(query: string, filters?: SearchFilters): Promise<Manga[]> {
    // Try default source first
    const source = this.sources.get(this.defaultSource);
    if (source) {
      try {
        const results = await source.search(query, filters);
        // We return the results even if empty, as long as the search succeeded
        return results;
      } catch (e) {
        console.error(
          `[SourceManager] Default source (${this.defaultSource}) failed:`,
          e,
        );
      }
    }

    // Fallback to other available sources
    console.log('[SourceManager] Attempting fallback sources...');
    for (const [id, src] of this.sources.entries()) {
      if (id === this.defaultSource) continue;
      try {
        const results = await src.search(query, filters);
        if (results.length > 0) {
          console.log(`[SourceManager] Success using fallback: ${id}`);
          return results;
        }
      } catch (e) {
        console.error(`[SourceManager] Fallback source (${id}) failed:`, e);
      }
    }

    return [];
  }
}

export const sourceManager = new SourceManager();


--------------------------------

FILE: services/mangago/index.ts
SIZE: 8.88 KB
TYPE: ts

CONTENT:
import { parse } from 'node-html-parser';
import { NetworkLogService } from '../networkLog';
import type { Manga, MangaDetails, MangaSource, SearchFilters } from '../types';

// Helper for debug logging
const log = (msg: string) => console.log(`[Mangago] ${msg}`);
const logError = (msg: string, e?: any) => console.error(`[Mangago] ${msg}`, e);

export const MangagoService = {
  id: 'mangago',
  name: 'Mangago',
  baseUrl: 'https://mangago.me',
  isNsfwSource: true,

  async search(query: string, _filters?: SearchFilters): Promise<Manga[]> {
    try {
      log(`Searching for: ${query}`);
      const url = `${this.baseUrl}/r/l_search/?name=${encodeURIComponent(query)}`;

      const response = await fetch(url, {
        headers: {
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          Referer: this.baseUrl,
        },
      });

      if (!response.ok) {
        throw new Error(`Status ${response.status}`);
      }

      const html = await response.text();
      const root = parse(html);

      // Select search results
      // Mangago usually lists results in <ul id="search_list"> <li>...</li>
      const items = root.querySelectorAll('#search_list li');

      return items
        .map((item) => {
          const titleEl = item.querySelector('.title a');
          const imgEl = item.querySelector('.left img');
          const genreEl = item.querySelector('.genre');

          const url = titleEl?.getAttribute('href') || '';
          const id = url.split('/read-manga/')[1]?.replace(/\/$/, '') || '';

          return {
            id: `mangago:${id}`,
            title: titleEl?.text?.trim() || 'Unknown',
            url: url,
            cover: imgEl?.getAttribute('src') || '',
            source: 'mangago',
          };
        })
        .filter((m) => m.id !== 'mangago:');
    } catch (e) {
      logError('Search failed', e);
      return [];
    }
  },

  async getMangaDetails(idOrUrl: string): Promise<MangaDetails | null> {
    try {
      let url = idOrUrl;
      if (!idOrUrl.startsWith('http')) {
        const id = idOrUrl.replace(/^mangago:/, '');
        url = `${this.baseUrl}/read-manga/${id}/`;
      }

      log(`Fetching details: ${url}`);
      const response = await fetch(url, {
        headers: {
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          Referer: this.baseUrl,
        },
      });

      if (!response.ok) throw new Error(`Status ${response.status}`);

      const html = await response.text();
      const root = parse(html);

      const title = root.querySelector('.w-title')?.text?.trim() || 'Unknown';
      const cover = root.querySelector('.cover img')?.getAttribute('src') || '';
      const plot = root.querySelector('#noid')?.text?.trim() || '';

      // Chapters table
      const chapterRows = root.querySelectorAll('#chapter_table tr');
      const chapters = chapterRows
        .map((row) => {
          const link = row.querySelector('a');
          if (!link) return null;

          const chUrl = link.getAttribute('href') || '';
          const chTitle = link.text.trim();

          // Mangago chapter URLs: /read-manga/manga_id/bt/chapter_id/
          // Extract ID?
          // Let's use the full URL path as ID for simplicity or hash it

          return {
            id: chUrl,
            title: chTitle,
            url: chUrl,
            source: 'mangago',
          };
        })
        .filter((c) => c !== null) as any[];

      return {
        id: idOrUrl,
        title,
        url,
        cover,
        description: plot,
        chapters,
        source: 'mangago',
      };
    } catch (e) {
      logError('Details failed', e);
      return null;
    }
  },

  async getChapterPages(chapterIdOrUrl: string): Promise<string[]> {
    try {
      let url = chapterIdOrUrl;
      if (!url.startsWith('http')) {
        url = `${this.baseUrl}${chapterIdOrUrl}`;
      }

      log(`Fetching chapter: ${url}`);
      const response = await fetch(url, {
        headers: {
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          Referer: this.baseUrl,
        },
      });

      const html = await response.text();
      const root = parse(html);

      // Mangago has all images or requires one page at a time?
      // Usually Mangago has "All pages" mode or single page.
      // We typically look for javascript array "imgsrcs"

      // Match imgsrcs var
      const scriptContent = root
        .querySelectorAll('script')
        .map((s) => s.text)
        .join('\n');
      const match =
        scriptContent.match(/var\s+imgsrcs\s*=\s*new\s+Array\((.*?)\);/s) ||
        scriptContent.match(/imgsrcs\s*=\s*\[(.*?)\]/s);

      if (match) {
        const raw = match[1];
        // cleanup quotes and split
        const urls = raw
          .replace(/['"\s\n]/g, '')
          .split(',')
          .filter((u) => u);
        return urls;
      }

      return [];
    } catch (e) {
      logError('Chapter pages failed', e);
      return [];
    }
  },

  async getHomeFeed(): Promise<{ popular: Manga[]; latest: Manga[] }> {
    try {
      log('Fetching home feed...');
      const [popular, latest] = await Promise.all([
        this.getPopular(),
        this.getLatest(),
      ]);
      return { popular, latest };
    } catch (e) {
      logError('getHomeFeed failed', e);
      return { popular: [], latest: [] };
    }
  },

  async getPopular(): Promise<Manga[]> {
    try {
      // Use directory sorted by views (guessing param o=v based on common engines, or default)
      // If o=v doesn't work, it defaults to alphabetical, which is better than empty.
      const url = `${this.baseUrl}/list/directory/all/1/?o=v`;
      log(`Fetching popular: ${url}`);

      const response = await fetch(url, {
        headers: {
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          Referer: this.baseUrl,
        },
      });

      const html = await response.text();
      const root = parse(html);

      // Directory items structure: .flex1.listitem
      const items = root.querySelectorAll('.listitem');

      return items
        .map((item) => {
          const left = item.querySelector('.left');
          const link = left?.querySelector('a');
          const img = left?.querySelector('img');
          const titleSpan = item.querySelector('span.title a');

          const fullUrl = link?.getAttribute('href') || '';
          // Extract ID: /read-manga/manga_id/
          const id = fullUrl.split('/read-manga/')[1]?.replace(/\/$/, '') || '';

          return {
            id: `mangago:${id}`,
            title:
              titleSpan?.text?.trim() ||
              link?.getAttribute('title') ||
              'Unknown',
            url: fullUrl,
            cover:
              img?.getAttribute('data-src') || img?.getAttribute('src') || '',
            source: 'mangago',
          };
        })
        .filter((m) => m.id !== 'mangago:');
    } catch (e) {
      logError('getPopular failed', e);
      return [];
    }
  },

  async getLatest(): Promise<Manga[]> {
    try {
      // Scrape homepage for "Latest Updates"
      // They are usually in li.toplist
      const url = this.baseUrl;
      log(`Fetching latest from homepage: ${url}`);

      const response = await fetch(url, {
        headers: {
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          Referer: this.baseUrl,
        },
      });

      const html = await response.text();
      const root = parse(html);

      const items = root.querySelectorAll('li.toplist');

      return items
        .map((item) => {
          const left = item.querySelector('.left.listimg');
          const link = left?.querySelector('a');
          const img = left?.querySelector('img');

          // Title is in .right h3 a
          const titleEl = item.querySelector('.right h3 a');

          const fullUrl = link?.getAttribute('href') || '';
          const id = fullUrl.split('/read-manga/')[1]?.replace(/\/$/, '') || '';

          const latestChapter = item
            .querySelector('.right ul li a')
            ?.text?.trim();

          return {
            id: `mangago:${id}`,
            title:
              titleEl?.text?.trim() || link?.getAttribute('title') || 'Unknown',
            url: fullUrl,
            cover:
              img?.getAttribute('data-src') || img?.getAttribute('src') || '',
            latestChapter: latestChapter,
            source: 'mangago',
          };
        })
        .filter((m) => m.id !== 'mangago:');
    } catch (e) {
      logError('getLatest failed', e);
      return [];
    }
  },
};


--------------------------------

FILE: services/mangapark/index.ts
SIZE: 18.24 KB
TYPE: ts

CONTENT:
import { logCapture } from '../debugLog';
import type { Manga, MangaDetails, MangaSource, SearchFilters } from '../types';
import { mapGenreToApi } from '../types';

// Helper for debug logging
const log = (msg: string) => logCapture('log', `[Mangapark] ${msg}`);
const logError = (msg: string, e?: any) => {
  const errStr = e ? e.message || String(e) : 'Unknown Error';
  logCapture('error', `[Mangapark] ${msg}: ${errStr}`);
};

const HEADERS = {
  'User-Agent':
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  Referer: 'https://mangakatana.com',
};

const BASE_URL = 'https://mangakatana.com';

const GENRE_ID_BY_SLUG: Record<string, number> = {
  '4-koma': 44,
  action: 14,
  adult: 18,
  adventure: 15,
  artbook: 46,
  'award-winning': 45,
  comedy: 2,
  cooking: 39,
  doujinshi: 25,
  drama: 3,
  ecchi: 23,
  erotica: 34,
  fantasy: 24,
  'gender-bender': 33,
  gore: 11,
  harem: 20,
  historical: 26,
  horror: 37,
  isekai: 49,
  josei: 4,
  loli: 42,
  manhua: 38,
  manhwa: 10,
  'martial-arts': 22,
  mecha: 28,
  medical: 41,
  music: 47,
  mystery: 5,
  'one-shot': 32,
  'overpowered-mc': 50,
  psychological: 6,
  reincarnation: 52,
  romance: 7,
  'school-life': 8,
  'sci-fi': 16,
  seinen: 19,
  'sexual-violence': 31,
  shota: 43,
  shoujo: 27,
  'shoujo-ai': 35,
  shounen: 17,
  'shounen-ai': 29,
  'slice-of-life': 9,
  sports: 12,
  'super-power': 48,
  supernatural: 21,
  survival: 51,
  'time-travel': 53,
  tragedy: 30,
  webtoon: 36,
  yaoi: 40,
  yuri: 13,
};

function fixUrl(url: string | undefined | null): string {
  if (!url) return '';
  if (url.startsWith('//')) {
    return `https:${url}`;
  }
  if (url.startsWith('/')) {
    return `${BASE_URL}${url}`;
  }
  return url;
}

function parseRelativeDate(dateStr: string): number {
  const now = Date.now();
  const clean = dateStr.toLowerCase().trim();

  if (clean.includes('ago')) {
    const num = parseInt(clean.match(/\d+/)?.[0] || '0', 10);
    if (clean.includes('minute')) return now - num * 60 * 1000;
    if (clean.includes('hour')) return now - num * 60 * 60 * 1000;
    if (clean.includes('day')) return now - num * 24 * 60 * 60 * 1000;
    if (clean.includes('week')) return now - num * 7 * 24 * 60 * 60 * 1000;
    if (clean.includes('month')) return now - num * 30 * 24 * 60 * 60 * 1000;
    if (clean.includes('year')) return now - num * 365 * 24 * 60 * 60 * 1000;
    return now;
  }

  if (clean === 'yesterday') return now - 24 * 60 * 60 * 1000;
  if (clean === 'today') return now;

  // Try parsing regular date "Dec-23-2025"
  const parsed = Date.parse(dateStr);
  return isNaN(parsed) ? 0 : parsed;
}

// SAFE FETCH
async function fetchSafe(
  url: string,
  options: RequestInit = {},
  timeout = 15000,
): Promise<string> {
  try {
    log(`[Fetch] -> ${url}`);

    const fetchPromise = fetch(url, options);

    const timeoutPromise = new Promise<Response>((_, reject) => {
      setTimeout(() => reject(new Error(`Timeout ${timeout}ms`)), timeout);
    });

    const response = await Promise.race([fetchPromise, timeoutPromise]);

    if (!response.ok) {
      throw new Error(`Status ${response.status}`);
    }

    const text = await response.text();
    log(`[Fetch] <- ${response.status} (Length: ${text.length})`);
    return text;
  } catch (e: any) {
    const msg = e.message || String(e);
    logError(`[Fetch] Failed: ${url}`, msg);
    throw new Error(msg);
  }
}

export const MangaparkService: MangaSource = {
  id: 'mangapark',
  name: 'MangaPark',
  baseUrl: BASE_URL,
  isNsfwSource: false,
  headers: HEADERS,

  async search(query: string, filters?: SearchFilters): Promise<Manga[]> {
    try {
      const trimmedQuery = query.trim();
      const hasQuery = trimmedQuery.length > 0;

      const hasGenres = Boolean(filters?.genres?.length);
      const hasStatus = Boolean(filters && filters.status !== 'all');
      const hasCustomOrder = Boolean(
        filters && filters.sort !== 'latest' && filters.sort !== 'views_d030',
      );

      const hasFilters = hasGenres || hasStatus || hasCustomOrder;

      // 1-1 Parity with Website:
      // - If text is present, use Global Search Mode (/) for site-wide title search.
      // - If NO text but filters are active, use Directory Mode (/manga) for deep category browsing.
      // - Combined (Text + Filters): Use Global Search + Client-side filter to "target" specific titles in categories.
      const shouldUseDirectory = !hasQuery && hasFilters;
      const basePath = shouldUseDirectory
        ? `${this.baseUrl}/manga`
        : `${this.baseUrl}/`;
      const params: string[] = [];

      if (shouldUseDirectory) {
        // DIRECTORY MODE (Browse by Category)
        params.push('filter=1');
        params.push('include_mode=and');
        params.push('bookmark_opts=off');
        params.push('chapters=1');

        if (filters) {
          // Add Order
          const sortMap: Record<string, string> = {
            views_d030: 'views',
            latest: 'latest',
            new: 'new',
            az: 'az',
            numc: 'num_chapters',
          };
          const order = sortMap[filters.sort] || 'latest';
          params.push(`order=${order}`);

          // Add Status
          if (filters.status && filters.status !== 'all') {
            const statusMap: Record<string, string> = {
              ongoing: '1',
              completed: '2',
            };
            const statusValue = statusMap[filters.status];
            if (statusValue) {
              params.push(`status=${statusValue}`);
            }
          }

          // Add Genres (Concatenated Slugs with _)
          if (filters.genres && filters.genres.length > 0) {
            const genreSlugs = filters.genres
              .map((g) => mapGenreToApi(g))
              .filter(Boolean);

            if (genreSlugs.length > 0) {
              params.push(`include=${genreSlugs.join('_')}`);
            }
          }
        }
      } else {
        // GLOBAL SEARCH MODE (Targeted Title Search)
        params.push(`search=${encodeURIComponent(trimmedQuery)}`);
        params.push('search_by=book_name');
      }

      const queryString = params.length ? `?${params.join('&')}` : '';
      const url = `${basePath}${queryString}`;

      log(
        `[Search] Mode: ${shouldUseDirectory ? 'Directory' : 'GlobalSearch'}, Query: "${query}", URL: ${url}`,
      );
      const html = await fetchSafe(url, { headers: HEADERS });

      // Intermediate structure to hold data for client-side sorting/filtering
      type ScrapedManga = Manga & {
        _debugDate?: number;
        _debugChapterNum?: number;
      };

      const results: ScrapedManga[] = [];
      const blocks = html.split('<div class="item"');
      blocks.shift(); // discard header

      for (const block of blocks) {
        // Real results have a title link inside h3. Script templates don't.
        if (!block.includes('<h3 class="title">')) continue;

        const genreDataMatch = block.match(/data-genre="([^"]*)"/);
        const genreIds = genreDataMatch
          ? genreDataMatch[1]
              .split(',')
              .map((id) => Number.parseInt(id.trim(), 10))
              .filter((id) => Number.isFinite(id))
          : undefined;

        const titleMatch = block.match(
          /<h3 class="title">[\s\S]*?<a href="([^"]+)"[^>]*>([\s\S]*?)<\/a>/,
        );
        if (titleMatch) {
          const href = titleMatch[1];
          const title = titleMatch[2].replace(/<[^>]+>/g, '').trim();
          const imgMatch = block.match(/<img[\s\S]*?src="([^"]+)"/);

          const genres: string[] = [];
          const genreMatches = block.matchAll(
            /<a href="[^"]+\/genre\/[^"]+"[^>]*>([\s\S]*?)<\/a>/g,
          );
          for (const gm of genreMatches) {
            genres.push(gm[1].trim());
          }

          // Parse Status
          const statusMatch = block.match(/<div class="status ([^"]+)">/);
          const status = statusMatch
            ? statusMatch[1].trim().toLowerCase()
            : undefined;

          // Parse Latest Update (Date)
          let dateTs = 0;
          const dateMatch = block.match(/<div class="date">([\s\S]*?)<\/div>/);
          if (dateMatch) {
            // Strip any inner tags like <i class="icon"></i> and trim
            const dateStr = dateMatch[1].replace(/<[^>]+>/g, '').trim();
            dateTs = parseRelativeDate(dateStr);
          }

          // Parse Chapter Number (Best Effort)
          let chapterNum = 0;
          const chapterMatch = block.match(/Chapter\s+(\d+(\.\d+)?)/i);
          if (chapterMatch) {
            chapterNum = parseFloat(chapterMatch[1]);
          }

          results.push({
            id: `mangapark:${href.split('/').pop()}`,
            title: title,
            url: href,
            cover: imgMatch ? fixUrl(imgMatch[1]) : '',
            genres,
            genreIds: genreIds && genreIds.length > 0 ? genreIds : undefined,
            source: 'mangapark',
            status:
              status === 'completed' || status === 'ongoing'
                ? status
                : undefined,
            _debugDate: dateTs,
            _debugChapterNum: chapterNum,
          });
        }
      }

      log(`[Search] Found ${results.length} results`);

      // 1. Browsing Mode (Filters only, no text): Already server-side filtered.
      if (!hasQuery) {
        return results;
      }

      // 2. Searching Mode (Text + Filters): Apply resilient client-side verification
      let finalResults = results;

      // Filter by Genres
      if (hasFilters && filters?.genres?.length) {
        const requiredGenreIds = filters.genres
          .map((genre) => {
            const mapped = mapGenreToApi(genre);
            return mapped ? GENRE_ID_BY_SLUG[mapped] : undefined;
          })
          .filter((id): id is number => Number.isFinite(id));

        if (requiredGenreIds.length > 0) {
          const beforeCount = finalResults.length;
          finalResults = finalResults.filter((manga) => {
            // RELAXED (Inclusion-first) Logic:
            // If item is missing genre metadata during site-wide search, we INCLUDE it
            // to ensure you don't miss targeted results from incomplete server metadata.
            if (!manga.genreIds || manga.genreIds.length === 0) {
              return true;
            }
            return requiredGenreIds.every((id) => manga.genreIds?.includes(id));
          });
          log(
            `[Search] Targeted Filter (Genres): ${beforeCount} -> ${finalResults.length} (IDs: ${requiredGenreIds.join(
              ', ',
            )})`,
          );
        }
      }

      // Filter by Status (Client-side)
      if (filters?.status && filters.status !== 'all') {
        const beforeCount = finalResults.length;
        const targetStatus = filters.status; // 'ongoing' or 'completed'
        finalResults = finalResults.filter((m) => {
          if (!m.status) return true; // Keep if unknown status to be safe
          return m.status === targetStatus;
        });
        log(
          `[Search] Targeted Filter (Status): ${beforeCount} -> ${finalResults.length} (Target: ${targetStatus})`,
        );
      }

      // Sort (Client-side)
      if (filters?.sort) {
        const sort = filters.sort;
        log(`[Search] Client-side Sort: ${sort}`);
        finalResults.sort((a, b) => {
          switch (sort) {
            case 'latest':
              return (b._debugDate || 0) - (a._debugDate || 0);
            case 'az':
              return a.title.localeCompare(b.title);
            case 'numc':
              return (b._debugChapterNum || 0) - (a._debugChapterNum || 0);
            // 'views' not supported client-side, fallback to default (relevance)
            default:
              return 0;
          }
        });
      }

      // Clean up internal props
      return finalResults.map((r) => {
        const { _debugDate, _debugChapterNum, ...rest } = r;
        return rest;
      });
    } catch (e) {
      logError('Search failed', e);
      return [];
    }
  },

  async getMangaDetails(idOrUrl: string): Promise<MangaDetails | null> {
    try {
      let url = idOrUrl;
      if (!idOrUrl.startsWith('http')) {
        url = `${this.baseUrl}/manga/${idOrUrl.replace('mangapark:', '')}`;
      }

      const html = await fetchSafe(url, { headers: HEADERS });

      const titleMatch = html.match(/<h1 class="heading">([^<]+)<\/h1>/);
      const title = titleMatch ? titleMatch[1].trim() : 'Unknown';

      const coverMatch = html.match(
        /<div class="cover">[^<]*<img[^>]+src="([^"]+)"/,
      );
      const cover = coverMatch ? fixUrl(coverMatch[1]) : '';

      const descMatch = html.match(/<div class="summary">([\s\S]*?)<\/div>/);
      const descRaw = descMatch ? descMatch[1] : '';
      const description = descRaw.replace(/<[^>]+>/g, '').trim();

      const statusMatch = html.match(
        /<div class="status [^"]+">([^<]+)<\/div>/,
      );
      const status = statusMatch ? statusMatch[1].trim() : '';

      const authors: string[] = [];
      const authorBlockMatch = html.match(
        /<div class="authors">([\s\S]*?)<\/div>/,
      );
      if (authorBlockMatch) {
        const ams = authorBlockMatch[1].matchAll(/<a[^>]+>([^<]+)<\/a>/g);
        for (const am of ams) authors.push(am[1]);
      }

      const genres: string[] = [];
      const genreBlockMatch = html.match(
        /<div class="genres">([\s\S]*?)<\/div>/,
      );
      if (genreBlockMatch) {
        const gms = genreBlockMatch[1].matchAll(/<a[^>]+>([^<]+)<\/a>/g);
        for (const gm of gms) genres.push(gm[1]);
      }

      const chapters: any[] = [];
      const tableMatch = html.match(
        /<div class="chapters">([\s\S]*?)<\/table>/,
      );
      if (tableMatch) {
        const tableContent = tableMatch[1];
        const rowMatches = tableContent.matchAll(/<tr[^>]*>([\s\S]*?)<\/tr>/g);
        for (const rm of rowMatches) {
          const row = rm[1];
          const linkM = row.match(/<a href="([^"]+)">([^<]+)<\/a>/);
          if (linkM) {
            const chUrl = linkM[1];
            const chTitle = linkM[2];
            const timeM = row.match(/<div class="update_time">([^<]+)<\/div>/);
            chapters.push({
              id: chUrl,
              title: chTitle.trim(),
              url: chUrl,
              uploadDate: timeM ? timeM[1].trim() : '',
              source: 'mangapark',
            });
          }
        }
      }

      return {
        id: idOrUrl,
        title,
        url,
        cover,
        description,
        authors,
        genres,
        status,
        chapters,
        source: 'mangapark',
      };
    } catch (e) {
      logError('Details failed', e);
      return null;
    }
  },

  async getChapterPages(chapterIdOrUrl: string): Promise<string[]> {
    try {
      const html = await fetchSafe(chapterIdOrUrl, { headers: HEADERS });
      const scriptRegex = /var\s+[a-z0-9]+\s*=\s*\[(.*?)\];/gis;
      let match;
      while ((match = scriptRegex.exec(html)) !== null) {
        const arrayStr = match[1];
        const urls = arrayStr.match(/https?:\/\/[^'"]+/g);
        if (urls && urls.length > 5) {
          return [...new Set(urls)].map((u) => u.replace(/\\/g, ''));
        }
      }
      return [];
    } catch (e) {
      logError('Chapter pages failed', e);
      return [];
    }
  },

  async getHomeFeed(): Promise<{ popular: Manga[]; latest: Manga[] }> {
    try {
      log('Fetching home feed...');
      if (!this.getPopular || !this.getLatest) {
        throw new Error('Scrapers not implemented');
      }
      const [popular, latest] = await Promise.all([
        this.getPopular(),
        this.getLatest(),
      ]);
      return { popular, latest };
    } catch (e) {
      logError('getHomeFeed failed', e);
      return { popular: [], latest: [] };
    }
  },

  async getPopular(): Promise<Manga[]> {
    try {
      log('getPopular: Start');
      const html = await fetchSafe(BASE_URL, { headers: HEADERS });

      const results: Manga[] = [];
      const hotSectionMatch = html.match(
        /<div id="hot_book">([\s\S]*?)(?:<div id="ugh"|<div id="book_list"|<!--)/,
      );
      const content = hotSectionMatch ? hotSectionMatch[1] : html;

      const blocks = content.split('<div class="item"');
      blocks.shift();

      for (const block of blocks) {
        const linkMatch = block.match(
          /<h3 class="title">\s*<a href="([^"]+)">([^<]+)<\/a>/,
        );
        if (linkMatch) {
          const href = linkMatch[1];
          const title = linkMatch[2];
          const imgMatch = block.match(/<img[^>]+src="([^"]+)"/);
          results.push({
            id: `mangapark:${href.split('/').pop()}`,
            title: title.trim(),
            url: href,
            cover: imgMatch ? fixUrl(imgMatch[1]) : '',
            source: 'mangapark',
          });
        }
      }
      log(`[Popular] Found ${results.length} items`);
      return results.length > 0 ? results : this.search('');
    } catch (e) {
      logError('Popular failed', e);
      return [];
    }
  },

  async getLatest(): Promise<Manga[]> {
    try {
      log('getLatest: Start');
      const url = `${BASE_URL}/latest`;
      const html = await fetchSafe(url, { headers: HEADERS });

      const results: Manga[] = [];
      const blocks = html.split('<div class="item"');
      blocks.shift();

      for (const block of blocks) {
        // Robust match for Title and Href
        const titleMatch = block.match(
          /<h3 class="title">[\s\S]*?<a href="([^"]+)"[^>]*>([\s\S]*?)<\/a>/,
        );
        if (titleMatch) {
          const href = titleMatch[1];
          const title = titleMatch[2].replace(/<[^>]+>/g, '').trim();
          const imgMatch = block.match(/<img[\s\S]*?src="([^"]+)"/);

          const genres: string[] = [];
          // Match all genre links: /genre/name
          const genreMatches = block.matchAll(
            /<a href="[^"]+\/genre\/[^"]+"[^>]*>([\s\S]*?)<\/a>/g,
          );
          for (const gm of genreMatches) {
            genres.push(gm[1].trim());
          }

          results.push({
            id: `mangapark:${href.split('/').pop()}`,
            title: title,
            url: href,
            cover: imgMatch ? fixUrl(imgMatch[1]) : '',
            genres,
            source: 'mangapark',
          });
        }
      }
      log(`[Latest] Found ${results.length} items`);
      return results;
    } catch (e) {
      logError('Latest failed', e);
      return [];
    }
  },
};


--------------------------------

FILE: services/everythingmoe/index.ts
SIZE: 2.35 KB
TYPE: ts

CONTENT:
import { parse } from 'node-html-parser';

// Helper for debug logging
const log = (msg: string) => console.log(`[EverythingMoe] ${msg}`);
const logError = (msg: string, e?: any) =>
  console.error(`[EverythingMoe] ${msg}`, e);

export interface DiscoveredSource {
  name: string;
  url: string;
  isNsfw: boolean;
}

export const EverythingMoeService = {
  baseUrl: 'https://everythingmoe.com',

  async discoverSources(): Promise<DiscoveredSource[]> {
    try {
      log('Fetching source list...');
      const response = await fetch(this.baseUrl, {
        headers: {
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        },
      });

      if (!response.ok) throw new Error(`Status ${response.status}`);

      const html = await response.text();
      const root = parse(html);

      // The user mentioned: <i class="mdil mdil-view-dashboard"></i> Manga Reading <div class="sec-count">(87)</div>
      // We need to find the specific section for Manga Reading.
      // Inspecting the HTML structure of everythingmoe (conceptually):
      // Sections are usually containers. We can look for links that look like external sources.

      // Since I can't browse the site interactively, I'll assume a structure or search for common patterns.
      // Based on the hint, we look for "Manga Reading".

      // Let's grab all links and filter? Or try to find the specific container.
      // For now, let's implement a generic scraper that looks for card-like elements with external links.

      const sources: DiscoveredSource[] = [];
      const links = root.querySelectorAll('a.item-link'); // Hypothethical class

      // Fallback: finding all external links
      const allLinks = root.querySelectorAll('a');
      for (const link of allLinks) {
        const href = link.getAttribute('href');
        const title = link.text.trim();

        if (
          href &&
          href.startsWith('http') &&
          !href.includes('everythingmoe.com')
        ) {
          // Basic heuristic
          sources.push({
            name: title || href,
            url: href,
            isNsfw: false, // Can't easily determine without more parsing
          });
        }
      }

      return sources;
    } catch (e) {
      logError('Discovery failed', e);
      return [];
    }
  },
};


--------------------------------

FILE: services/comix/index.ts
SIZE: 10.00 KB
TYPE: ts

CONTENT:
import { logCapture } from '../debugLog';
import type { Manga, MangaDetails, MangaSource, SearchFilters } from '../types';

const log = (msg: string) => logCapture('log', `[Comix] ${msg}`);
const logError = (msg: string, e?: any) =>
  logCapture('error', `[Comix] ${msg}`, e);

interface ComixApiManga {
  manga_id: number;
  hash_id: string;
  title: string;
  slug: string;
  poster: { medium: string; large: string };
  status: string;
  latest_chapter: number;
}

interface ComixApiResponse {
  status: number;
  result: {
    items: ComixApiManga[];
  };
}

function parseApiManga(item: ComixApiManga): Manga {
  return {
    id: item.hash_id, // Use hash_id as the primary ID for API calls
    title: item.title,
    url: `https://comix.to/title/${item.slug}`,
    cover: item.poster?.medium || '',
    latestChapter: item.latest_chapter ? `Ch. ${item.latest_chapter}` : '',
    status: item.status === 'ongoing' ? 'Ongoing' : 'Completed',
    authors: [],
  };
}

export const ComixService: MangaSource = {
  id: 'comix',
  name: 'Comix',
  baseUrl: 'https://comix.to',
  isNsfwSource: false,
  headers: {
    'User-Agent':
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    Referer: 'https://comix.to/',
    Origin: 'https://comix.to',
  },

  async getPopular(): Promise<Manga[]> {
    try {
      log('Fetching popular via API');
      const response = await fetch(
        `${this.baseUrl}/api/v2/manga?sort=views_total&limit=20`,
        {
          headers: this.headers,
        },
      );
      const json: ComixApiResponse = await response.json();

      if (json && json.result && json.result.items) {
        const items = json.result.items.map(parseApiManga);
        log(`Popular: found ${items.length} items`);
        return items;
      }
      log('No items in popular response');
      return [];
    } catch (e) {
      logError('Failed to fetch popular manga', e);
      return [];
    }
  },

  async getLatest(): Promise<Manga[]> {
    try {
      log('Fetching latest via API');
      const response = await fetch(
        `${this.baseUrl}/api/v2/manga?sort=latest&limit=20`,
        {
          headers: this.headers,
        },
      );
      const json: ComixApiResponse = await response.json();

      if (json && json.result && json.result.items) {
        const items = json.result.items.map(parseApiManga);
        log(`Latest: found ${items.length} items`);
        return items;
      }
      log('No items in latest response');
      return [];
    } catch (e) {
      logError('Failed to fetch latest manga', e);
      return [];
    }
  },

  async getHomeFeed(): Promise<{ popular: Manga[]; latest: Manga[] }> {
    const [popular, latest] = await Promise.all([
      this.getPopular!(),
      this.getLatest!(),
    ]);
    return { popular, latest };
  },

  async search(query: string, filters?: SearchFilters): Promise<Manga[]> {
    try {
      const trimmedQuery = query.trim();
      const hasQuery = trimmedQuery.length > 0;

      // Check if we have any filters to apply
      const hasFilters =
        filters &&
        (filters.genres?.length ||
          filters.status !== 'all' ||
          filters.sort !== 'latest');

      log(
        `Searching for: "${trimmedQuery}" with filters: ${hasFilters ? 'yes' : 'no'}`,
      );

      const params: string[] = [];

      // Add query if present
      if (hasQuery) {
        params.push(`keyword=${encodeURIComponent(trimmedQuery)}`);
      }

      // Add sort parameter
      if (filters?.sort) {
        const sortMap: Record<string, string> = {
          latest: 'order[updated_at]=desc',
          new: 'order[created_at]=desc',
          az: 'order[title]=asc',
          numc: 'order[total_chapters]=desc',
          views_d030: 'order[views_30d]=desc',
        };
        const sortParam = sortMap[filters.sort];
        if (sortParam) {
          params.push(sortParam);
        }
      } else {
        // Default sort
        params.push('order[updated_at]=desc');
      }

      // Add status filter
      if (filters?.status && filters.status !== 'all') {
        const statusMap: Record<string, string> = {
          ongoing: 'status=releasing',
          completed: 'status=finished',
        };
        if (statusMap[filters.status]) {
          params.push(statusMap[filters.status]);
        }
      }

      // Add genre filters (Comix uses genre IDs, not names)
      // For now, we skip genre filtering since we'd need a mapping
      // The API supports: genres[]=87265 (include) or genres[]=-87265 (exclude)

      // Limit results
      params.push('limit=20');

      const queryString = params.join('&');
      const url = `${this.baseUrl}/api/v2/manga?${queryString}`;

      log(`[Search] URL: ${url}`);

      const response = await fetch(url, { headers: this.headers });
      const json: ComixApiResponse = await response.json();

      if (json && json.result && json.result.items) {
        const items = json.result.items.map(parseApiManga);
        log(`Search found ${items.length} items`);
        return items;
      }
      log('No items in search response');
      return [];
    } catch (e) {
      logError('Search failed', e);
      return [];
    }
  },

  async getMangaDetails(mangaId: string): Promise<MangaDetails> {
    log(`[Comix] START mangaId:${mangaId}`);
    try {
      log(`[Comix] getMangaDetails called with: ${mangaId}`);

      // mangaId is now the hash_id directly (e.g., "pgx4", "kl6nv")
      // Handle legacy URLs just in case
      let hashId = mangaId;
      if (mangaId.includes('comix.to/title/')) {
        hashId = mangaId.split('comix.to/title/')[1].split('-')[0];
      } else if (mangaId.startsWith('title/')) {
        hashId = mangaId.split('title/')[1].split('-')[0];
      } else if (mangaId.startsWith('/title/')) {
        hashId = mangaId.split('/title/')[1].split('-')[0];
      } else if (mangaId.includes('-')) {
        // Legacy: might be slug like "kl6nv-the-dukes-wife" - extract first part
        hashId = mangaId.split('-')[0];
      }

      log(`[Comix] Using hashId: ${hashId}`);

      const apiUrl = `${this.baseUrl}/api/v2/manga/${hashId}`;
      log(`[Comix] FETCH_URL:${apiUrl}`);
      log(`Fetching details from API: ${apiUrl}`);

      const apiRes = await fetch(apiUrl, {
        headers: this.headers,
      });
      log(`[Comix] RESPONSE_STATUS:${apiRes.status}`);

      const json = await apiRes.json();
      log(`API response status: ${json.status}`);

      if (!json || !json.result) {
        throw new Error(`API error: ${json?.message || 'Unknown error'}`);
      }

      const manga = json.result;
      log(`[Comix] MANGA_TITLE:${manga.title}`);

      // Fetch chapters from API with pagination
      log('[Comix] FETCHING_CHAPTERS');
      const allChapters: any[] = [];
      let currentPage = 1;
      let lastPage = 1;

      do {
        const chaptersRes = await fetch(
          `${this.baseUrl}/api/v2/manga/${hashId}/chapters?page=${currentPage}`,
          {
            headers: this.headers,
          },
        );
        const chaptersJson = await chaptersRes.json();

        if (chaptersJson && chaptersJson.result && chaptersJson.result.items) {
          chaptersJson.result.items.forEach((item: any) => {
            const chapId = `${item.chapter_id}-chapter-${item.number}`;
            const compositeId = `${hashId}:::${chapId}`;

            allChapters.push({
              id: compositeId,
              title: item.name || `Chapter ${item.number}`,
              number: item.number,
              date: new Date(item.created_at * 1000),
              url: `/title/${manga.slug}/${chapId}`,
            });
          });

          // Get pagination info
          if (chaptersJson.result.pagination) {
            lastPage = chaptersJson.result.pagination.last_page || 1;
          }
        }

        log(
          `[Comix] CHAPTERS_PAGE_${currentPage}:${allChapters.length} items (lastPage: ${lastPage})`,
        );
        currentPage++;
      } while (currentPage <= lastPage);

      log(`[Comix] TOTAL_CHAPTERS_FETCHED:${allChapters.length}`);

      return {
        id: manga.slug,
        title: manga.title,
        url: `${this.baseUrl}/title/${manga.slug}`,
        description: manga.synopsis || '',
        cover: manga.poster?.medium || '',
        authors: [],
        status: manga.status === 'releasing' ? 'Ongoing' : 'Completed',
        chapters: allChapters.sort((a, b) => b.number - a.number),
        isNsfw: manga.is_nsfw || false,
      } as MangaDetails;
    } catch (e) {
      logError('Failed to fetch details', e);
      throw e;
    }
  },

  async getChapterPages(chapterIdOrUrl: string): Promise<string[]> {
    try {
      let chapterId = '';

      // Format: "hash_id:::chapter_id-chapter-number"
      if (chapterIdOrUrl.includes(':::')) {
        const parts = chapterIdOrUrl.split(':::');
        const chapPart = parts[1]; // e.g., "6740075-chapter-1"
        chapterId = chapPart.split('-')[0]; // Extract "6740075"
      } else if (chapterIdOrUrl.includes('/')) {
        // URL format like /title/slug/chapter_id-chapter-number
        const parts = chapterIdOrUrl.split('/');
        const lastPart = parts[parts.length - 1];
        chapterId = lastPart.split('-')[0];
      } else {
        // Direct chapter ID
        chapterId = chapterIdOrUrl.split('-')[0];
      }

      if (!chapterId || isNaN(parseInt(chapterId))) {
        logError(`Invalid chapter ID: ${chapterIdOrUrl}`);
        return [];
      }

      const apiUrl = `${this.baseUrl}/api/v2/chapters/${chapterId}`;
      log(`Fetching chapter pages from API: ${apiUrl}`);

      const response = await fetch(apiUrl, { headers: this.headers });
      const json = await response.json();

      if (!json || !json.result || !json.result.images) {
        logError('Invalid API response for chapter pages');
        return [];
      }

      const images = json.result.images.map((img: any) => img.url);
      log(`Found ${images.length} images for chapter ${chapterId}`);
      return images;
    } catch (e) {
      logError('Failed to fetch chapter pages', e);
      return [];
    }
  },
};


--------------------------------

FILE: components/Search.tsx
SIZE: 1.54 KB
TYPE: tsx

CONTENT:
import { useEffect, useState } from '@lynx-js/react';
import './Search.css';

interface Props {
  onSearch: (query: string) => void;
  onFilterClick?: () => void;
  value?: string; // Controlled value from parent
}

export function Search({ onSearch, onFilterClick, value = '' }: Props) {
  const [query, setQuery] = useState(value);

  // Sync with parent value when it changes (e.g., on reset)
  useEffect(() => {
    setQuery(value);
  }, [value]);

  const handleSearch = () => {
    console.log(`[Search] Search triggered: "${query}"`);
    onSearch(query);
  };

  return (
    <view className="Search">
      <view className="Search-header">
        <text className="Search-title">Search</text>
      </view>
      <view className="Search-input-container">
        <view className="Search-box">
          <text className="Search-icon">🔍</text>
          <input
            key={value}
            type="text"
            className="Search-input"
            placeholder="Search manga..."
            placeholder-style="color: #8E8E93"
            show-soft-input-on-focus={true}
            bindinput={(e: any) => setQuery(e.detail.value)}
            bindconfirm={handleSearch}
          />
          <view className="Search-action" bindtap={handleSearch}>
            <text className="Search-action-text">Search</text>
          </view>
        </view>
        {onFilterClick && (
          <view className="FilterButton" bindtap={onFilterClick}>
            <text className="FilterIcon">⚙️</text>
          </view>
        )}
      </view>
    </view>
  );
}


--------------------------------

FILE: components/Search.css
SIZE: 1.30 KB
TYPE: css

CONTENT:
.Search {
  display: flex;
  flex-direction: column;
  padding: 50px 16px 16px 16px;
  background-color: var(--surface);
  border-bottom: 1px solid var(--accent-soft);
}

.Search-title {
  font-size: 24px;
  font-weight: 800;
  color: var(--text-accent);
  margin-bottom: 20px;
  margin-left: 4px;
}

.Search-input-container {
  display: flex;
  flex-direction: row;
  align-items: center;
  width: 100%;
}

.Search-box {
  flex: 1;
  display: flex;
  flex-direction: row;
  align-items: center;
  background-color: var(--bg-main);
  border-radius: 16px;
  height: 48px;
  padding: 0 16px;
  margin-right: 12px;
  border: 1px solid var(--accent-soft);
}

.Search-icon {
  font-size: 16px;
  margin-right: 10px;
  opacity: 0.5;
}

.Search-input {
  flex: 1;
  height: 48px;
  background-color: transparent;
  color: var(--text-primary);
  font-size: 17px;
  font-weight: 500;
}

.Search-action {
  padding: 8px 16px;
  background-color: var(--text-accent);
  border-radius: 12px;
}

.Search-action-text {
  color: #ffffff;
  font-size: 14px;
  font-weight: 700;
}

.FilterButton {
  width: 48px;
  height: 48px;
  background-color: var(--bg-main);
  border-radius: 16px;
  justify-content: center;
  align-items: center;
  display: flex;
  border: 1px solid var(--accent-soft);
}

.FilterIcon {
  font-size: 20px;
  opacity: 0.8;
}


--------------------------------

FILE: components/BottomNav.tsx
SIZE: 1.14 KB
TYPE: tsx

CONTENT:
import './BottomNav.css';

type Tab = 'home' | 'search' | 'settings';

interface Props {
  activeTab: Tab;
  onTabChange: (tab: Tab) => void;
}

export function BottomNav({ activeTab, onTabChange }: Props) {
  return (
    <view className="BottomNav">
      <view
        className={
          activeTab === 'home' ? 'BottomNav-tab active' : 'BottomNav-tab'
        }
        bindtap={() => onTabChange('home')}
      >
        <text className="BottomNav-icon">🏠</text>
        <text className="BottomNav-label">Home</text>
      </view>
      <view
        className={
          activeTab === 'search' ? 'BottomNav-tab active' : 'BottomNav-tab'
        }
        bindtap={() => onTabChange('search')}
      >
        <text className="BottomNav-icon">💖</text>
        <text className="BottomNav-label">Search/Browse</text>
      </view>
      <view
        className={
          activeTab === 'settings' ? 'BottomNav-tab active' : 'BottomNav-tab'
        }
        bindtap={() => onTabChange('settings')}
      >
        <text className="BottomNav-icon">⚙️</text>
        <text className="BottomNav-label">Settings</text>
      </view>
    </view>
  );
}


--------------------------------

FILE: components/SearchFilters.css
SIZE: 2.82 KB
TYPE: css

CONTENT:
.FiltersOverlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(74, 63, 63, 0.4);
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  z-index: 1000;
}

.FiltersSheet {
  display: flex;
  flex-direction: column;
  background-color: var(--surface);
  border-top-left-radius: 32px;
  border-top-right-radius: 32px;
  padding: 24px;
  height: 85%; /* Using fixed height to ensure scroll-view has a constraint */
  box-shadow: 0 -10px 40px rgba(74, 63, 63, 0.1);
}

.FiltersHeader {
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--accent-soft);
}

.FiltersTitle {
  font-size: 20px;
  font-weight: 800;
  color: var(--text-primary);
  letter-spacing: 0.5px;
}

.ResetButton {
  font-size: 14px;
  font-weight: 700;
  color: var(--text-accent);
}

.ResetButton:active {
  opacity: 0.6;
}

.FiltersContent {
  flex: 1;
  width: 100%;
}

.FiltersScroll {
  flex: 1;
}

.FilterSection {
  margin-bottom: 24px;
}

.SectionLabel {
  font-size: 12px;
  font-weight: 800;
  color: var(--text-secondary);
  margin-bottom: 16px;
  letter-spacing: 1px;
}

.ChipRow {
  flex-direction: row;
  flex-wrap: wrap;
}

.Chip {
  padding: 10px 20px;
  border-radius: 100px;
  background-color: var(--bg-main);
  border: 1px solid var(--accent-border);
  margin-right: 12px;
  margin-bottom: 12px;
}

.Chip-active {
  background-color: var(--text-accent);
  border-color: var(--text-accent);
}

.Chip:active {
  opacity: 0.7;
}

.ChipText {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-secondary);
}

.Chip-active .ChipText {
  color: #ffffff;
}

.GenreGrid {
  flex-direction: row;
  flex-wrap: wrap;
  padding-bottom: 40px;
}

.GenreChip {
  padding: 10px 18px;
  border-radius: 12px;
  background-color: var(--surface);
  border: 1px solid var(--accent-soft);
  margin-right: 10px;
  margin-bottom: 10px;
}

.GenreChip-active {
  background-color: var(--accent-soft);
  border-color: var(--text-accent);
}

.GenreChip:active {
  opacity: 0.7;
}

.GenreChipText {
  color: var(--text-primary);
  font-size: 13px;
  font-weight: 500;
}

.GenreText {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-primary);
}

.GenreChipText-active {
  color: var(--text-accent); /* Standardizing to SMUTHUB colors */
  font-weight: 700;
}

.FilterActions {
  padding-top: 16px;
  padding-bottom: 24px;
  background-color: var(--surface);
}

.ApplyButton {
  background-color: var(--text-accent); /* Standardizing to SMUTHUB colors */
  border-radius: 16px;
  height: 54px;
  justify-content: center;
  align-items: center;
  box-shadow: 0 4px 12px rgba(212, 122, 148, 0.25);
}

.ApplyButton:active {
  transform: scale(0.98);
  opacity: 0.9;
}

.ApplyButtonText {
  color: #ffffff;
  font-size: 16px;
  font-weight: 700;
}


--------------------------------

FILE: components/BottomNav.css
SIZE: 734 bytes
TYPE: css

CONTENT:
/* Floating Bottom Navigation */
.BottomNav {
  position: fixed;
  bottom: 20px;
  left: 24px;
  right: 24px;
  height: 64px;
  background-color: var(--glass);
  border-radius: 24px;
  display: flex;
  flex-direction: row;
  justify-content: space-around;
  align-items: center;
  box-shadow: var(--shadow-soft);
  border: 1px solid var(--accent-border);
  z-index: 1000;
}

.BottomNav-tab {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 8px 16px;
}

.BottomNav-icon {
  font-size: 22px;
  margin-bottom: 2px;
}

.BottomNav-label {
  font-size: 10px;
  font-weight: 600;
  color: var(--text-secondary);
  letter-spacing: 0.3px;
}

.BottomNav-tab.active .BottomNav-label {
  color: var(--text-accent);
}


--------------------------------

FILE: components/MangaDetailsUi.css
SIZE: 3.76 KB
TYPE: css

CONTENT:
/* Manga Details Page */
.DetailsContainer {
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: var(--surface);
}

/* Header with Backdrop */
.DetailsHeader {
  height: 320px;
  position: relative;
  overflow: hidden;
}

.DetailsBackdrop {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  filter: blur(20px);
  opacity: 0.6;
}

.DetailsHeaderOverlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    to bottom,
    rgba(0, 0, 0, 0.7) 0%,
    rgba(0, 0, 0, 0.2) 40%,
    var(--surface) 100%
  );
  padding: 50px 24px 24px 24px;
  display: flex;
  flex-direction: column;
}

.HeaderNav {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.BackButton {
  font-size: 16px;
  font-weight: 600;
  color: #ffffff;
}

.DetailsFavorite {
  width: 40px;
  height: 40px;
  border-radius: 20px;
  background-color: rgba(255, 255, 255, 0.25);
  display: flex;
  align-items: center;
  justify-content: center;
}

.DetailsFavorite.active {
  background-color: rgba(255, 255, 255, 0.4);
}

.DetailsFavorite-icon {
  font-size: 20px;
}

.HeaderContent {
  flex: 1;
  display: flex;
  flex-direction: row;
  align-items: flex-end;
}

.DetailsCover {
  width: 120px;
  height: 160px;
  border-radius: 16px;
  box-shadow: var(--shadow-soft);
  border: 3px solid #ffffff;
  margin-right: 16px;
}

.HeaderInfo {
  flex: 1;
  padding-bottom: 8px;
}

.DetailsTitle {
  font-size: 20px;
  font-weight: 700;
  color: var(--text-primary);
  line-height: 1.2;
  margin-bottom: 8px;
}

.DetailsBadges {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  margin-bottom: 8px;
}

.Badge {
  padding: 4px 10px;
  border-radius: 8px;
  font-size: 11px;
  font-weight: 700;
  margin-right: 8px;
  margin-bottom: 4px;
}

.Badge.status {
  background-color: var(--accent-soft);
  color: var(--text-accent);
}

.Badge.rating {
  background-color: #fff3cd;
  color: #856404;
}

.DetailsMeta {
  font-size: 13px;
  color: var(--text-secondary);
  line-height: 1.4;
}

/* Details Body */
.DetailsBody {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 24px 24px 0 24px;
  background-color: var(--surface);
  border-top-left-radius: 32px;
  border-top-right-radius: 32px;
  margin-top: -24px;
}

.DescriptionSection {
  margin-bottom: 20px;
}

.DescriptionText {
  font-size: 14px;
  color: var(--text-secondary);
  line-height: 1.6; /* 22.4px per line */
  max-height: 68px; /* ~3 lines */
  overflow: hidden;
}

.DescriptionText.expanded {
  max-height: 2000px;
}

.ExpandHint {
  font-size: 13px;
  color: var(--text-accent);
  font-weight: 600;
  margin-top: 8px;
}

/* Genre Tags */
.GenreRow {
  margin-bottom: 24px;
  display: flex;
  flex-direction: row;
}

.GenreTag {
  padding: 8px 16px;
  border-radius: 100px;
  background-color: var(--bg-main);
  border: 1px solid var(--accent-border);
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
  margin-right: 10px;
}

/* Chapter Actions */
.ChapterActions {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--accent-soft);
}

.SortButton {
  padding: 8px 16px;
  background-color: var(--bg-main);
  border-radius: 12px;
  border: 1px solid var(--accent-soft);
}

.SortText {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-accent);
}

/* Chapter List */
.DetailsChapterList {
  flex: 1;
}

.DetailChapterItem {
  padding: 16px 0;
  border-bottom: 1px solid var(--accent-soft);
}

.ChTitle {
  font-size: 15px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 4px;
}

.ChMeta {
  font-size: 12px;
  color: var(--text-secondary);
}


--------------------------------

FILE: components/FavoritesView.tsx
SIZE: 2.27 KB
TYPE: tsx

CONTENT:
import { useEffect, useState } from '@lynx-js/react';
import { StorageService } from '../services/storage';
import type { Manga } from '../services/types';
import { MangaCard } from './MangaCard';
import './FavoritesView.css';

interface Props {
  onBack: () => void;
  onSelectManga: (manga: Manga) => void;
}

export function FavoritesView({ onBack, onSelectManga }: Props) {
  const [favorites, setFavorites] = useState<Manga[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadFavorites();
  }, []);

  const loadFavorites = async () => {
    setLoading(true);
    try {
      const result = await StorageService.getFavorites();
      setFavorites(result.data);
    } catch (e) {
      console.error('[FavoritesView] Failed to load:', e);
    } finally {
      setLoading(false);
    }
  };

  const handleSelectManga = (manga: Manga) => {
    onSelectManga(manga);
  };

  return (
    <view className="FavoritesView">
      <view className="FavoritesView-header">
        <text className="FavoritesView-back" bindtap={onBack}>
          ‹ Back
        </text>
        <text className="FavoritesView-title">Favorites</text>
        <view className="FavoritesView-spacer" />
      </view>

      <scroll-view className="FavoritesView-content" scroll-y>
        {loading ? (
          <view className="FavoritesView-loading">
            <text className="FavoritesView-loading-text">
              Loading favorites...
            </text>
          </view>
        ) : favorites.length === 0 ? (
          <view className="FavoritesView-empty">
            <text className="FavoritesView-empty-icon">💔</text>
            <text className="FavoritesView-empty-title">No Favorites Yet</text>
            <text className="FavoritesView-empty-subtitle">
              Tap the heart on any manga to add it here
            </text>
          </view>
        ) : (
          <view className="FavoritesView-grid">
            {favorites.map((manga) => (
              <view key={manga.id} className="FavoritesView-item">
                <MangaCard
                  manga={manga}
                  onSelect={handleSelectManga}
                  showFavoriteButton={true}
                />
              </view>
            ))}
          </view>
        )}
      </scroll-view>
    </view>
  );
}


--------------------------------

FILE: components/FavoritesView.css
SIZE: 1.55 KB
TYPE: css

CONTENT:
/* Favorites View */
.FavoritesView {
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: var(--bg-main);
  width: 100%;
  height: 100%;
}

.FavoritesView-header {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 50px 24px 16px 24px;
  background-color: var(--glass);
}

.FavoritesView-back {
  font-size: 17px;
  font-weight: 600;
  color: var(--text-accent);
  width: 60px;
}

.FavoritesView-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--text-primary);
}

.FavoritesView-spacer {
  width: 60px;
}

.FavoritesView-content {
  flex: 1;
  padding: 16px 24px 100px 24px;
}

.FavoritesView-loading {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 60px;
}

.FavoritesView-loading-text {
  font-size: 15px;
  color: var(--text-secondary);
}

.FavoritesView-empty {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60px 24px;
}

.FavoritesView-empty-icon {
  font-size: 64px;
  margin-bottom: 24px;
}

.FavoritesView-empty-title {
  font-size: 20px;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: 8px;
  text-align: center;
}

.FavoritesView-empty-subtitle {
  font-size: 15px;
  color: var(--text-secondary);
  text-align: center;
  line-height: 1.4;
}

.FavoritesView-grid {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
}

.FavoritesView-item {
  width: 50%;
  padding: 0 10px 20px 0;
}

.FavoritesView-item:nth-child(2n) {
  padding: 0 0 20px 10px;
}


--------------------------------

FILE: components/HistoryView.css
SIZE: 2.74 KB
TYPE: css

CONTENT:
/* History View */
.HistoryView {
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: var(--bg-main);
  width: 100%;
  height: 100%;
}

.HistoryView-header {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 50px 24px 16px 24px;
  background-color: var(--glass);
}

.HistoryView-back {
  font-size: 17px;
  font-weight: 600;
  color: var(--text-accent);
  width: 60px;
}

.HistoryView-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--text-primary);
}

.HistoryView-spacer {
  width: 60px;
}

.HistoryView-content {
  flex: 1;
  padding: 16px 24px 100px 24px;
}

.HistoryView-loading {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 60px;
}

.HistoryView-loading-text {
  font-size: 15px;
  color: var(--text-secondary);
}

.HistoryView-empty {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60px 24px;
}

.HistoryView-empty-icon {
  font-size: 64px;
  margin-bottom: 24px;
}

.HistoryView-empty-title {
  font-size: 20px;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: 8px;
  text-align: center;
}

.HistoryView-empty-subtitle {
  font-size: 15px;
  color: var(--text-secondary);
  text-align: center;
  line-height: 1.4;
}

.HistoryView-list {
  display: flex;
  flex-direction: column;
}

/* History Item - List style */
.HistoryView-item {
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 12px;
  background-color: var(--surface);
  border: 1px solid var(--accent-border);
  border-radius: 16px;
  margin-bottom: 12px;
  box-shadow: var(--shadow-soft);
}

.HistoryView-item-cover {
  width: 60px;
  height: 80px;
  border-radius: 10px;
  overflow: hidden;
  background-color: var(--bg-main);
}

.HistoryView-item-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 0 12px;
}

.HistoryView-item-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 4px;
  line-height: 1.3;
}

.HistoryView-item-chapter {
  font-size: 13px;
  color: var(--text-accent);
  font-weight: 500;
  margin-bottom: 4px;
}

.HistoryView-item-meta {
  display: flex;
  flex-direction: row;
  align-items: center;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 4px;
}

.HistoryView-item-badge-container {
  background-color: var(--primary);
  border-radius: 4px;
  padding: 2px 6px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.HistoryView-item-badge {
  font-size: 10px;
  font-weight: 800;
  color: #ffffff;
}

.HistoryView-item-time {
  font-size: 12px;
  color: var(--text-secondary);
}

.HistoryView-item-chevron {
  font-size: 20px;
  color: var(--text-secondary);
  font-weight: 300;
}


--------------------------------

FILE: components/UpdateModal.tsx
SIZE: 2.33 KB
TYPE: tsx

CONTENT:
import { useState } from '@lynx-js/react';
import { type AppUpdate, UpdateService } from '../services/update';
import './UpdateModal.css';

interface Props {
  update: AppUpdate;
  nativeUrl?: string; // If provided, this is a native APK update
  onDismiss: () => void;
}

export function UpdateModal({ update, nativeUrl, onDismiss }: Props) {
  const [isUpdating, setIsUpdating] = useState(false);

  const handleUpdate = () => {
    setIsUpdating(true);
    if (nativeUrl) {
      UpdateService.installNativeUpdate(nativeUrl);
    } else {
      UpdateService.applyUpdate(update);
    }
  };

  const formattedNotes = update.releaseNotes
    ? update.releaseNotes.replace(/\\n/g, '\n').replace(/\\r/g, '\r')
    : 'Performance improvements and bug fixes.';

  return (
    <view className="UpdateOverlay">
      <view className="UpdateCard">
        <view className="UpdateHeader">
          <view className="UpdateIconContainer">
            <text className="UpdateIcon">{nativeUrl ? '📦' : '🚀'}</text>
          </view>
          <text className="UpdateTitle">
            {nativeUrl ? 'Native Update Available' : 'New Update Available'}
          </text>
          <text className="UpdateVersion">Version {update.version}</text>
        </view>

        <view className="UpdateBody">
          <text className="UpdateBodyTitle">What's New:</text>
          <scroll-view className="UpdateNotes" scroll-y>
            <text className="NotesText">{formattedNotes}</text>
          </scroll-view>

          <text className="UpdateHint">
            {nativeUrl
              ? 'This is a native app update. Tapping below will download and install the new APK.'
              : 'The app will reload to apply the latest changes.'}
          </text>
        </view>

        <view className="UpdateActions">
          <view className="UpdateButton" bindtap={handleUpdate}>
            <text className="UpdateButtonText">
              {isUpdating
                ? 'Updating...'
                : nativeUrl
                  ? 'Install Update'
                  : 'Update Now'}
            </text>
          </view>

          {!update.isMandatory && !isUpdating && (
            <view className="LaterButton" bindtap={onDismiss}>
              <text className="LaterButtonText">Maybe Later</text>
            </view>
          )}
        </view>
      </view>
    </view>
  );
}


--------------------------------

FILE: components/Sparkles.css
SIZE: 1.14 KB
TYPE: css

CONTENT:
.SparklesWrapper {
  position: relative;
  display: inline-flex;
  overflow: visible;
}

.SparkleInstance {
  position: absolute;
  pointer-events: none;
}

.mode-sparkle {
  animation: sparkle-animation 750ms linear forwards;
}

.mode-fall {
  animation: fall-animation 3000ms ease-in forwards;
}

.mode-drift {
  animation: drift-animation 2000ms ease-out forwards;
}

.SparkleChildWrapper {
  position: relative;
  z-index: 1;
}

@keyframes sparkle-animation {
  0% {
    transform: scale(0) rotate(0deg);
    opacity: 0;
  }
  50% {
    transform: scale(1.2) rotate(90deg);
    opacity: 1;
  }
  100% {
    transform: scale(0) rotate(180deg);
    opacity: 0;
  }
}

@keyframes fall-animation {
  0% {
    transform: translateY(-20px) translateX(0) rotate(0deg);
    opacity: 0;
  }
  10% {
    opacity: 1;
  }
  80% {
    opacity: 1;
  }
  100% {
    transform: translateY(100px) translateX(20px) rotate(360deg);
    opacity: 0;
  }
}

@keyframes drift-animation {
  0% {
    transform: translateY(20px) scale(0.5);
    opacity: 0;
  }
  20% {
    opacity: 0.8;
  }
  100% {
    transform: translateY(-60px) translateX(-10px) scale(1.5);
    opacity: 0;
  }
}


--------------------------------

FILE: components/SearchFilters.tsx
SIZE: 6.83 KB
TYPE: tsx

CONTENT:
import { useCallback, useState } from '@lynx-js/react';
import type { SearchFilters } from '../services/types';
import './SearchFilters.css';

interface Props {
  onApply: (filters: SearchFilters) => void;
  onClose: () => void;
  onReset?: () => void; // Optional callback to reset search query
  initialFilters?: SearchFilters; // Pre-populate with saved filters
}

// Complete genre list from Batoto
const GENRES = [
  '4-Koma',
  'Action',
  'Adult',
  'Adventure',
  'Artbook',
  'Award Winning',
  'Comedy',
  'Cooking',
  'Doujinshi',
  'Drama',
  'Ecchi',
  'Fantasy',
  'Gender Bender',
  'Harem',
  'Historical',
  'Horror',
  'Isekai',
  'Josei',
  'Loli',
  'Manhua',
  'Manhwa',
  'Martial Arts',
  'Mecha',
  'Medical',
  'Music',
  'Mystery',
  'One Shot',
  'Overpowered MC',
  'Psychological',
  'Reincarnation',
  'Romance',
  'School Life',
  'Sci-fi',
  'Seinen',
  'Shota',
  'Shoujo',
  'Shoujo Ai',
  'Shounen',
  'Shounen Ai',
  'Slice of Life',
  'Sports',
  'Super Power',
  'Supernatural',
  'Survival',
  'Time Travel',
  'Tragedy',
  'Webtoon',
  'Yaoi',
  'Yuri',
];

export const GENRE_MAP: Record<string, string> = {
  '4-Koma': '4-koma',
  Action: 'action',
  Adult: 'adult',
  Adventure: 'adventure',
  Artbook: 'artbook',
  'Award Winning': 'award-winning',
  Comedy: 'comedy',
  Cooking: 'cooking',
  Doujinshi: 'doujinshi',
  Drama: 'drama',
  Ecchi: 'ecchi',
  Fantasy: 'fantasy',
  'Gender Bender': 'gender-bender',
  Harem: 'harem',
  Historical: 'historical',
  Horror: 'horror',
  Isekai: 'isekai',
  Josei: 'josei',
  Loli: 'loli',
  Manhua: 'manhua',
  Manhwa: 'manhwa',
  'Martial Arts': 'martial-arts',
  Mecha: 'mecha',
  Medical: 'medical',
  Music: 'music',
  Mystery: 'mystery',
  'One Shot': 'one-shot',
  'Overpowered MC': 'overpowered-mc',
  Psychological: 'psychological',
  Reincarnation: 'reincarnation',
  Romance: 'romance',
  'School Life': 'school-life',
  'Sci-fi': 'sci-fi',
  Seinen: 'seinen',
  Shota: 'shota',
  Shoujo: 'shoujo',
  'Shoujo Ai': 'shoujo-ai',
  Shounen: 'shounen',
  'Shounen Ai': 'shounen-ai',
  'Slice of Life': 'slice-of-life',
  Sports: 'sports',
  'Super Power': 'super-power',
  Supernatural: 'supernatural',
  Survival: 'survival',
  'Time Travel': 'time-travel',
  Tragedy: 'tragedy',
  Webtoon: 'webtoon',
  Yaoi: 'yaoi',
  Yuri: 'yuri',
};

export function SearchFiltersModal({
  onApply,
  onClose,
  onReset,
  initialFilters,
}: Props) {
  const [filters, setFilters] = useState<SearchFilters>(
    initialFilters || {
      genres: [],
      status: 'all',
      sort: 'views_d030',
      nsfw: false,
    },
  );

  const toggleGenre = (genre: string) => {
    setFilters((prev: SearchFilters) => ({
      ...prev,
      genres: prev.genres.includes(genre)
        ? prev.genres.filter((g: string) => g !== genre)
        : [...prev.genres, genre],
    }));
  };

  const handleReset = () => {
    const resetFilters: SearchFilters = {
      genres: [],
      status: 'all',
      sort: 'views_d030',
      nsfw: false,
    };
    setFilters(resetFilters);
    onReset?.(); // Clear search query
    onApply(resetFilters); // Apply reset immediately
  };

  const SORT_OPTIONS = [
    { value: 'latest', label: 'Latest Update' },
    { value: 'new', label: 'New Manga' },
    { value: 'az', label: 'A-Z' },
    { value: 'numc', label: 'Most Chapters' },
  ];

  const STATUS_OPTIONS = [
    { value: 'all', label: 'All' },
    { value: 'ongoing', label: 'Ongoing' },
    { value: 'completed', label: 'Completed' },
    { value: 'cancelled', label: 'Cancelled' },
  ];

  return (
    <view className="FiltersOverlay" bindtap={onClose}>
      <view className="FiltersSheet" catchtap={() => {}}>
        <view className="FiltersHeader">
          <text className="FiltersTitle">Search Filters</text>
          <text className="ResetButton" bindtap={handleReset}>
            Reset
          </text>
        </view>

        <scroll-view className="FiltersContent" scroll-y>
          <text className="SectionLabel">Sort By</text>
          <view className="ChipRow">
            {SORT_OPTIONS.map((s) => (
              <view
                key={s.value}
                className={
                  filters.sort === s.value ? 'Chip Chip-active' : 'Chip'
                }
                bindtap={() =>
                  setFilters((prev: SearchFilters) => ({
                    ...prev,
                    sort: s.value as any,
                  }))
                }
              >
                <text
                  className={
                    filters.sort === s.value
                      ? 'ChipText ChipText-active'
                      : 'ChipText'
                  }
                >
                  {s.label}
                </text>
              </view>
            ))}
          </view>

          <text className="SectionLabel">Status</text>
          <view className="ChipRow">
            {STATUS_OPTIONS.map((s) => (
              <view
                key={s.value}
                className={
                  filters.status === s.value ? 'Chip Chip-active' : 'Chip'
                }
                bindtap={() =>
                  setFilters((prev: SearchFilters) => ({
                    ...prev,
                    status: s.value as any,
                  }))
                }
              >
                <text
                  className={
                    filters.status === s.value
                      ? 'ChipText ChipText-active'
                      : 'ChipText'
                  }
                >
                  {s.label}
                </text>
              </view>
            ))}
          </view>

          <text className="SectionLabel">Genres</text>
          <view className="GenreGrid">
            {GENRES.map((g) => (
              <view
                key={g}
                className={
                  filters.genres.includes(g)
                    ? 'GenreChip GenreChip-active'
                    : 'GenreChip'
                }
                bindtap={() => toggleGenre(g)}
              >
                <text
                  className={
                    filters.genres.includes(g)
                      ? 'GenreChipText GenreChipText-active'
                      : 'GenreChipText'
                  }
                >
                  {g}
                </text>
              </view>
            ))}
          </view>
        </scroll-view>

        <view className="FilterActions">
          <view className="ApplyButton" bindtap={() => onApply(filters)}>
            <text className="ApplyButtonText">Apply Filters</text>
          </view>
        </view>
      </view>
    </view>
  );
}

// Minimal inline styles for now, usually goes in .css
// .FiltersOverlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 100; justify-content: flex-end; }
// .FiltersSheet { background: #fff; border-top-left-radius: 20px; border-top-right-radius: 20px; padding: 20px; height: 70%; }


--------------------------------

FILE: components/UpdateModal.css
SIZE: 2.34 KB
TYPE: css

CONTENT:
.UpdateOverlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 40px;
  z-index: 2000;
}

.UpdateCard {
  width: 320px;
  background-color: var(--surface);
  border-radius: 32px;
  overflow: hidden;
  box-shadow: var(--shadow-soft);
  display: flex;
  flex-direction: column;
}

.UpdateHeader {
  padding: 32px 24px 20px 24px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.UpdateIconContainer {
  width: 64px;
  height: 64px;
  background-color: var(--accent-soft);
  border-radius: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 16px;
}

.UpdateIcon {
  font-size: 32px;
}

.UpdateTitle {
  font-size: 22px;
  font-weight: 800;
  color: var(--text-primary);
  text-align: center;
  margin-bottom: 4px;
}

.UpdateVersion {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-accent);
}

.UpdateBody {
  padding: 0 24px 24px 24px;
  display: flex;
  flex-direction: column;
}

.UpdateBodyTitle {
  font-size: 13px;
  font-weight: 700;
  color: var(--text-secondary);
  letter-spacing: 0.5px;
  margin-bottom: 10px;
}

.UpdateNotes {
  height: 140px;
  background-color: var(--bg-main);
  border-radius: 16px;
  padding: 16px;
  margin-bottom: 16px;
  display: flex;
  flex-direction: column;
}

.NotesText {
  font-size: 15px;
  color: var(--text-primary);
  line-height: 1.5;
}

.UpdateHint {
  font-size: 12px;
  color: var(--text-secondary);
  text-align: center;
  font-style: italic;
  margin-bottom: 8px;
}

.UpdateActions {
  padding: 0 24px 32px 24px;
  display: flex;
  flex-direction: column;
}

.UpdateButton {
  background-color: var(--text-accent);
  padding: 16px;
  border-radius: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 15px rgba(212, 122, 148, 0.3);
  margin-bottom: 12px;
}

.UpdateButtonText {
  color: #ffffff;
  font-size: 16px;
  font-weight: 700;
}

.LaterButton {
  padding: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.LaterButtonText {
  color: var(--text-secondary);
  font-size: 14px;
  font-weight: 600;
}

/* Dark mode adjustments if needed */
.Main.dark-mode .UpdateCard {
  background-color: #2d2d2d;
}

.Main.dark-mode .UpdateNotes {
  background-color: #1a1a1a;
}


--------------------------------

FILE: components/ErrorBoundary.css
SIZE: 1.04 KB
TYPE: css

CONTENT:
/* ErrorBoundary Fallback UI */
.ErrorBoundary {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
  padding: 32px;
}

.ErrorBoundary-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  max-width: 320px;
}

.ErrorBoundary-icon {
  font-size: 64px;
  margin-bottom: 24px;
}

.ErrorBoundary-title {
  font-size: 24px;
  font-weight: 700;
  color: #fff;
  text-align: center;
  margin-bottom: 12px;
}

.ErrorBoundary-message {
  font-size: 14px;
  color: #a0a0b0;
  text-align: center;
  margin-bottom: 24px;
  line-height: 1.5;
}

.ErrorBoundary-version {
  font-size: 12px;
  color: #666;
  margin-bottom: 32px;
}

.ErrorBoundary-button {
  background: linear-gradient(135deg, #e91e63 0%, #9c27b0 100%);
  padding: 14px 32px;
  border-radius: 12px;
  box-shadow: 0 4px 16px rgba(233, 30, 99, 0.3);
}

.ErrorBoundary-button-text {
  font-size: 16px;
  font-weight: 600;
  color: #fff;
}


--------------------------------

FILE: components/__tests__/HistoryView.test.ts
SIZE: 1.82 KB
TYPE: ts

CONTENT:
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { timeAgo } from '../../utils/formatters';

describe('HistoryView Logic', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should return "Just now" for times < 1 minute ago', () => {
    const now = new Date('2024-01-01T12:00:00Z');
    vi.setSystemTime(now);

    // 30 seconds ago
    const past = new Date('2024-01-01T11:59:30Z').toISOString();
    expect(timeAgo(past)).toBe('Just now');
  });

  it('should format minutes correctly', () => {
    const now = new Date('2024-01-01T12:00:00Z');
    vi.setSystemTime(now);

    // 10 minutes ago
    const past = new Date('2024-01-01T11:50:00Z').toISOString();
    expect(timeAgo(past)).toBe('10m ago');
  });

  it('should format hours correctly', () => {
    const now = new Date('2024-01-01T12:00:00Z');
    vi.setSystemTime(now);

    // 5 hours ago
    const past = new Date('2024-01-01T07:00:00Z').toISOString();
    expect(timeAgo(past)).toBe('5h ago');
  });

  it('should format days correctly', () => {
    const now = new Date('2024-01-01T12:00:00Z');
    vi.setSystemTime(now);

    // 3 days ago
    const past = new Date('2023-12-29T12:00:00Z').toISOString();
    expect(timeAgo(past)).toBe('3d ago');
  });

  it('should format weeks correctly', () => {
    const now = new Date('2024-01-01T12:00:00Z');
    vi.setSystemTime(now);

    // 2 weeks ago (14 days)
    const past = new Date('2023-12-18T12:00:00Z').toISOString();
    expect(timeAgo(past)).toBe('2w ago');
  });

  it('should format months correctly', () => {
    const now = new Date('2024-01-01T12:00:00Z');
    vi.setSystemTime(now);

    // 2 months ago (60 days)
    const past = new Date('2023-11-02T12:00:00Z').toISOString();
    expect(timeAgo(past)).toBe('2mo ago');
  });
});


--------------------------------

FILE: components/DeveloperOptions.tsx
SIZE: 25.80 KB
TYPE: tsx

CONTENT:
import { useState } from '@lynx-js/react'; // Ensure useEffect is imported
import { DebugLogService } from '../services/debugLog';
import { SettingsStore } from '../services/settings';
import { StorageService } from '../services/storage';
import { BUNDLE_VERSION, UpdateService } from '../services/update';
import { NetworkInspector } from './NetworkInspector';
import { StateInspector } from './StateInspector';
import { SyncMonitor } from './SyncMonitor';
import './Settings.css';

export function DeveloperOptions() {
  const deviceId = StorageService.getDeviceId();
  const [showDebugConsole, setShowDebugConsole] = useState(false);
  const [showNetworkInspector, setShowNetworkInspector] = useState(false);
  const [showSyncMonitor, setShowSyncMonitor] = useState(false);
  const [showStateInspector, setShowStateInspector] = useState(false);
  const [debugReport, setDebugReport] = useState('');
  const [copyStatus, setCopyStatus] = useState('');
  const [deviceIdOverrideInput, setDeviceIdOverrideInput] = useState('');
  const [debugOutlines, setDebugOutlines] = useState(
    SettingsStore.getDebugOutlines(),
  );
  const [mockUpdates, setMockUpdates] = useState(
    SettingsStore.get().mockUpdates || false,
  );
  const [showTicketModal, setShowTicketModal] = useState(false);
  const [ticketSubject, setTicketSubject] = useState('');
  const [ticketBody, setTicketBody] = useState('');

  const submitToDiscord = async () => {
    if (!ticketSubject || !ticketBody) {
      setCopyStatus('❌ Fill all fields');
      setTimeout(() => setCopyStatus(''), 2000);
      return;
    }

    setCopyStatus('🔄 Fetching Config...');

    try {
      // Dynamically import to ensure circular deps don't bite, although import at top is fine.
      // Re-using the service directly.
      const { SupabaseService } = await import('../services/supabase');
      const webhookUrl = await SupabaseService.getGlobalConfig(
        'discord_webhook_url',
      );

      if (!webhookUrl) {
        setCopyStatus('❌ Config Error (DB)');
        console.error(
          '[DeveloperOptions] ' +
            'Missing "discord_webhook_url" in Supabase table "app_config". ' +
            'Please add this key/value pair in your database.',
        );
        setTimeout(() => setCopyStatus(''), 4000);
        return;
      }

      setCopyStatus('🚀 Sending...');

      // Get native version synchronously if available
      let nativeVersion = 'N/A';
      try {
        if (
          typeof NativeModules !== 'undefined' &&
          NativeModules.NativeUpdaterModule &&
          NativeModules.NativeUpdaterModule.getNativeVersion
        ) {
          nativeVersion = NativeModules.NativeUpdaterModule.getNativeVersion();
        }
      } catch (e) {
        console.warn('[DeveloperOptions] Failed to get native version', e);
      }

      const payload = {
        username: 'Supa Support',
        embeds: [
          {
            title: `Ticket: ${ticketSubject}`,
            description: ticketBody,
            color: 15258703, // Pink-ish
            fields: [
              { name: 'Device ID', value: deviceId || 'Unknown', inline: true },
              { name: 'App Version', value: BUNDLE_VERSION, inline: true },
              { name: 'Native Version', value: nativeVersion, inline: true },
              { name: 'Timestamp', value: new Date().toISOString() },
            ],
            footer: { text: 'Submitted via Developer Options' },
          },
        ],
      };

      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        setCopyStatus('✅ Sent!');
        setTimeout(() => {
          setShowTicketModal(false);
          setTicketSubject('');
          setTicketBody('');
          setCopyStatus('');
        }, 1500);
      } else {
        const errText = await response.text();
        console.error(
          '[DeveloperOptions] Discord API Error:',
          response.status,
          errText,
        );
        setCopyStatus(`❌ Error ${response.status}`);
      }
    } catch (e: any) {
      console.error('[DeveloperOptions] Submission failed:', e);
      setCopyStatus(`❌ Error: ${e.message || 'Network'}`);
    }
  };

  const handleToggleDebugOutlines = () => {
    const newVal = !debugOutlines;
    setDebugOutlines(newVal);
    SettingsStore.setDebugOutlines(newVal);
  };

  const handleToggleMockUpdates = () => {
    const newVal = !mockUpdates;
    setMockUpdates(newVal);
    SettingsStore.setMockUpdates(newVal);
  };

  const handleSetDeviceOverride = () => {
    if (!deviceIdOverrideInput) {
      setCopyStatus('❌ Enter an ID');
      setTimeout(() => setCopyStatus(''), 2000);
      return;
    }
    StorageService.setDeviceIdOverride(deviceIdOverrideInput);
    setCopyStatus('✅ Device ID Overridden!');
    setTimeout(() => setCopyStatus(''), 2000);
  };

  const handleClearDeviceOverride = () => {
    StorageService.clearDeviceIdOverride();
    setDeviceIdOverrideInput('');
    setCopyStatus('✅ Override Cleared');
    setTimeout(() => setCopyStatus(''), 2000);
  };

  const handleOpenDebugConsole = async () => {
    // Gather context for the report
    const settings = SettingsStore.get();
    const deviceId = StorageService.getDeviceId();

    // Fetch all known native storage keys
    const storageValues: Record<string, string | null> = {};
    const keys = [
      'batoto:favorites',
      'batoto:history',
      'batoto:settings',
      'batoto:filters',
      'batoto:device_id',
      'batoto:reader_position',
    ];

    for (const key of keys) {
      storageValues[key] = await StorageService.getNativeItemSync(key);
    }

    const report = DebugLogService.getDebugReport({
      settings,
      deviceId,
      version: BUNDLE_VERSION,
      storageValues,
      supabaseStatus: {
        lastSync: 'See console logs',
        note: 'Supabase sync runs in background via SyncEngine',
      },
    });

    setDebugReport(report);
    setShowDebugConsole(true);
    setCopyStatus('');
  };

  const handleSaveToDb = async () => {
    setCopyStatus('⏳ Saving to database...');
    try {
      const { SupabaseService } = await import('../services/supabase');
      const deviceId = StorageService.getDeviceId();
      const settings = SettingsStore.get();

      // Fetch storage for context
      const storageValues: Record<string, string | null> = {};
      const keys = [
        'batoto:favorites',
        'batoto:history',
        'batoto:settings',
        'batoto:filters',
        'batoto:device_id',
        'batoto:reader_position',
      ];

      for (const key of keys) {
        storageValues[key] = await StorageService.getNativeItemSync(key);
      }

      const structuredReport = DebugLogService.getStructuredReport({
        settings,
        deviceId,
        version: BUNDLE_VERSION,
        storageValues,
        supabaseStatus: {
          status: 'Captured via DeveloperOptions',
        },
      });

      const success = await SupabaseService.upsert(
        'debug_logs',
        {
          device_id: deviceId,
          // Legacy support (optional, can be removed)
          report: debugReport,
          // New Structured Data
          app_version: structuredReport.app_version,
          environment_info: structuredReport.environment_info,
          settings: structuredReport.settings,
          supabase_status: structuredReport.supabase_status,
          storage_state: structuredReport.storage_state,
          console_logs: structuredReport.console_logs,
          created_at: new Date().toISOString(),
        },
        'device_id',
      );

      if (success) {
        setCopyStatus('✅ Debug log saved to database!');
      } else {
        setCopyStatus('❌ Failed to save to database');
      }
    } catch (e: any) {
      console.error('[DeveloperOptions] Save to DB failed:', e);
      setCopyStatus(`❌ Save failed: ${e?.message || 'Unknown error'}`);
    }

    // Clear status after 3s
    setTimeout(() => setCopyStatus(''), 3000);
  };

  const handleForceUpdateCheck = async () => {
    setCopyStatus('🔍 Checking for updates...');
    try {
      const update = await UpdateService.checkUpdate();
      if (update) {
        setCopyStatus(`🚀 Update v${update.version} found! Check Home page.`);
      } else {
        setCopyStatus('✅ App is up to date.');
      }
      // Refresh report to show new logs
      const report = DebugLogService.getDebugReport({
        settings: SettingsStore.get(),
        deviceId: StorageService.getDeviceId(),
        version: BUNDLE_VERSION,
        storageValues: {
          skippedVersion: StorageService.getSkippedVersion() || 'None',
        },
      });
      setDebugReport(report);
    } catch (e: any) {
      setCopyStatus(`❌ Check failed: ${e.message}`);
    }
  };

  const handleVerifyUpdates = async () => {
    setCopyStatus('🔍 Verifying updates...');
    try {
      // Force check (bypass throttle)
      const updatesMap = await StorageService.checkFavoritesForUpdates(true);
      const updates = Array.from(updatesMap.values());

      setCopyStatus(`✅ Check complete: ${updates.length} items found.`);

      // Prepare report
      const { SupabaseService } = await import('../services/supabase');
      const deviceId = StorageService.getDeviceId();

      const report = {
        verification_type: 'chapter_update_check',
        timestamp: new Date().toISOString(),
        results: updates.map((m) => ({
          id: m.id,
          title: m.title,
          latest_chapter: m.latestChapter,
          latest_url: m.latestChapterUrl,
          latest_id: m.latestChapterId,
        })),
        log_summary: `Checked ${updates.length} items. Force=true.`,
      };

      await SupabaseService.upsert('debug_logs', {
        device_id: deviceId,
        report: JSON.stringify(report, null, 2),
        console_logs: ['[DeveloperOptions] Verification run completed'],
        created_at: new Date().toISOString(),
      });

      setCopyStatus('✅ Verification saved to DB!');
    } catch (e: any) {
      console.error('[DeveloperOptions] Verification failed:', e);
      setCopyStatus(`❌ Failed: ${e.message}`);
    }

    // Clear status
    setTimeout(() => setCopyStatus(''), 3000);
  };

  const handleRefreshReport = async () => {
    const settings = SettingsStore.get();
    const deviceId = StorageService.getDeviceId();
    const storageValues: Record<string, string | null> = {};
    const keys = [
      'batoto:favorites',
      'batoto:history',
      'batoto:settings',
      'batoto:filters',
      'batoto:device_id',
      'batoto:reader_position',
    ];
    for (const key of keys) {
      storageValues[key] = await StorageService.getNativeItemSync(key);
    }

    const report = DebugLogService.getDebugReport({
      settings,
      deviceId,
      version: BUNDLE_VERSION,
      storageValues,
    });
    setDebugReport(report);
    setCopyStatus('🔄 Refreshed');
    setTimeout(() => setCopyStatus(''), 2000);
  };

  return (
    <>
      <view className="Settings-section">
        <text className="Settings-section-title">DEVELOPER</text>

        <view className="Settings-item">
          <view className="Settings-item-left">
            <text className="Settings-item-icon">🆔</text>
            <view className="Settings-item-text">
              <text className="Settings-item-label">Stable Device ID</text>
              <text className="Settings-item-description">{deviceId}</text>
            </view>
          </view>
        </view>

        <view className="Settings-card">
          {/* Persona Override - Icon + Input Row */}
          <view className="Settings-item-left">
            <text className="Settings-item-icon">🤖</text>
            <view className="Settings-item-text">
              <input
                className="Settings-input-inline"
                // @ts-expect-error
                value={deviceIdOverrideInput}
                bindinput={(e: any) => setDeviceIdOverrideInput(e.detail.value)}
                placeholder="Device ID / UUID"
                placeholder-style="color: var(--text-secondary); opacity: 0.5;"
              />
              <text className="Settings-item-description">
                Override user persona for testing
              </text>
            </view>
          </view>

          {/* Action Buttons Row */}
          <view className="Settings-button-row">
            <view
              className="Settings-button danger"
              bindtap={handleClearDeviceOverride}
            >
              <text className="Settings-button-text">CLEAR</text>
            </view>
            <view
              className={
                deviceIdOverrideInput
                  ? 'Settings-button primary'
                  : 'Settings-button primary disabled'
              }
              bindtap={handleSetDeviceOverride}
            >
              <text className="Settings-button-text">APPLY</text>
            </view>
          </view>
        </view>

        <view className="Settings-item">
          <view className="Settings-item-left">
            <text className="Settings-item-icon">🛠️</text>
            <view className="Settings-item-text">
              <text className="Settings-item-label">Environment</text>
              <text className="Settings-item-description">Lynx Runtime</text>
            </view>
          </view>
        </view>

        <view className="Settings-item" bindtap={handleOpenDebugConsole}>
          <view className="Settings-item-left">
            <text className="Settings-item-icon">🐛</text>
            <view className="Settings-item-text">
              <text className="Settings-item-label">Debug Console</text>
              <text className="Settings-item-description">
                View logs & system info ({DebugLogService.count()} entries)
              </text>
            </view>
          </view>
          <text className="Settings-item-chevron">›</text>
        </view>

        <view
          className="Settings-item"
          bindtap={() => setShowNetworkInspector(true)}
        >
          <view className="Settings-item-left">
            <text className="Settings-item-icon">📡</text>
            <view className="Settings-item-text">
              <text className="Settings-item-label">Network Inspector</text>
              <text className="Settings-item-description">
                Monitor API traffic and headers
              </text>
            </view>
          </view>
          <text className="Settings-item-chevron">›</text>
        </view>

        <view
          className="Settings-item"
          bindtap={() => setShowSyncMonitor(true)}
        >
          <view className="Settings-item-left">
            <text className="Settings-item-icon">🔄</text>
            <view className="Settings-item-text">
              <text className="Settings-item-label">Sync Monitor</text>
              <text className="Settings-item-description">
                View background sync queue & status
              </text>
            </view>
          </view>
          <text className="Settings-item-chevron">›</text>
        </view>

        <view
          className="Settings-item"
          bindtap={() => setShowStateInspector(true)}
        >
          <view className="Settings-item-left">
            <text className="Settings-item-icon">💾</text>
            <view className="Settings-item-text">
              <text className="Settings-item-label">State Inspector</text>
              <text className="Settings-item-description">
                View & clear local storage keys
              </text>
            </view>
          </view>
          <text className="Settings-item-chevron">›</text>
        </view>

        <view className="Settings-item">
          <view className="Settings-item-left">
            <text className="Settings-item-icon">📐</text>
            <view className="Settings-item-text">
              <text className="Settings-item-label">Layout Debugger</text>
              <text className="Settings-item-description">
                Show element outlines
              </text>
            </view>
          </view>
          <view
            className={
              debugOutlines ? 'Settings-toggle active' : 'Settings-toggle'
            }
            bindtap={handleToggleDebugOutlines}
          >
            <view className="Settings-toggle-knob" />
          </view>
        </view>

        <view className="Settings-item">
          <view className="Settings-item-left">
            <text className="Settings-item-icon">🎭</text>
            <view className="Settings-item-text">
              <text className="Settings-item-label">Mock Updates</text>
              <text className="Settings-item-description">
                Force "NEW" badge on all history
              </text>
            </view>
          </view>
          <view
            className={
              mockUpdates ? 'Settings-toggle active' : 'Settings-toggle'
            }
            bindtap={handleToggleMockUpdates}
          >
            <view className="Settings-toggle-knob" />
          </view>
        </view>

        <view
          className="Settings-item"
          bindtap={() => setShowTicketModal(true)}
        >
          <view className="Settings-item-left">
            <text className="Settings-item-icon">🎫</text>
            <view className="Settings-item-text">
              <text className="Settings-item-label">Submit Ticket</text>
              <text className="Settings-item-description">
                Report a bug or feature request
              </text>
            </view>
          </view>
          <text className="Settings-item-chevron">›</text>
        </view>
      </view>

      {/* Ticket Modal */}
      {showTicketModal && (
        <view
          className="DebugConsole-overlay"
          bindtap={() => {
            setShowTicketModal(false);
            setCopyStatus('');
          }}
        >
          <view
            className="DebugConsole-modal"
            catchtap={() => {}}
            style={{ height: 'auto', maxHeight: '90%', padding: '20px' }}
          >
            <view
              className="DebugConsole-header"
              style={{ borderBottomWidth: 0, paddingBottom: 0 }}
            >
              <text className="DebugConsole-title">🎫 Submit Ticket</text>
              <view
                className="DebugConsole-button"
                bindtap={() => setShowTicketModal(false)}
              >
                <text className="DebugConsole-button-text">✕</text>
              </view>
            </view>

            <view
              className="Settings-card"
              style={{ marginTop: '20px', marginBottom: 0 }}
            >
              <text className="Settings-input-label">Subject</text>
              <input
                className="Settings-input"
                // @ts-expect-error
                value={ticketSubject}
                bindinput={(e: any) => setTicketSubject(e.detail.value)}
                placeholder="Brief summary..."
                placeholder-style="color: var(--text-secondary);"
              />

              <text
                className="Settings-input-label"
                style={{ marginTop: '16px' }}
              >
                Description
              </text>
              <textarea
                className="Settings-input"
                style={{ height: '120px', paddingTop: '10px' }}
                // @ts-expect-error
                value={ticketBody}
                bindinput={(e: any) => setTicketBody(e.detail.value)}
                placeholder="Describe the issue or request..."
                placeholder-style="color: var(--text-secondary);"
              />

              <view
                className="Settings-button-row"
                style={{ marginTop: '24px' }}
              >
                <view
                  className="Settings-button primary"
                  style={{ flex: 1, height: '44px' }}
                  bindtap={submitToDiscord}
                >
                  <text
                    className="Settings-button-text"
                    style={{ color: 'white' }}
                  >
                    Submit Ticket
                  </text>
                </view>
              </view>
            </view>
          </view>
        </view>
      )}

      {/* Debug Console Modal */}
      {showDebugConsole && (
        <view
          className="DebugConsole-overlay"
          bindtap={() => setShowDebugConsole(false)}
        >
          <view className="DebugConsole-modal" catchtap={() => {}}>
            <view className="DebugConsole-header">
              <text className="DebugConsole-title">🐛 Debug Console</text>
              <view
                className="DebugConsole-button"
                bindtap={() => setShowDebugConsole(false)}
              >
                <text className="DebugConsole-button-text">✕</text>
              </view>
            </view>
            <view className="DebugConsole-toolbar">
              <view
                className="DebugConsole-button"
                bindtap={handleRefreshReport}
              >
                <text className="DebugConsole-button-text">🔄</text>
              </view>
              <view
                className="DebugConsole-button"
                bindtap={handleForceUpdateCheck}
              >
                <text className="DebugConsole-button-text">🆙</text>
              </view>
              <view
                className="DebugConsole-button"
                bindtap={handleVerifyUpdates}
              >
                <text className="DebugConsole-button-text">
                  🔎 Batch Verify
                </text>
              </view>
              <view
                className="DebugConsole-button primary"
                bindtap={handleSaveToDb}
              >
                <text className="DebugConsole-button-text">💾 Save</text>
              </view>
            </view>

            {copyStatus && (
              <view className="DebugConsole-status">
                <text className="DebugConsole-status-text">{copyStatus}</text>
              </view>
            )}

            <scroll-view className="DebugConsole-content" scroll-y>
              {debugReport.split('\n').map((line, i) => {
                let color = '#ccc'; // Default text color
                if (line.startsWith('=')) color = '#666';
                else if (line.startsWith('---')) color = '#00e676';
                else if (line.includes('[ERROR]')) color = '#ff5252';
                else if (line.includes('[WARN]')) color = '#ffab40';
                else if (line.includes('[INFO]')) color = '#40c4ff';
                else if (line.includes('[DEBUG]')) color = '#b0bec5';
                else if (line.startsWith('[UpdateService]')) color = '#e040fb'; // Special color for update service

                return (
                  <text
                    key={i}
                    className="DebugConsole-line"
                    style={{ color, fontSize: '10px', fontFamily: 'monospace' }}
                  >
                    {line}
                  </text>
                );
              })}
            </scroll-view>
          </view>
        </view>
      )}

      {/* Network Inspector Modal */}
      {showNetworkInspector && (
        <view
          className="DebugConsole-overlay"
          bindtap={() => setShowNetworkInspector(false)}
        >
          <view
            className="DebugConsole-modal"
            catchtap={() => {}}
            style={{ padding: 0, backgroundColor: 'transparent' }}
          >
            <view className="DebugConsole-header" style={{ marginBottom: 0 }}>
              <text className="DebugConsole-title">📡 Network Inspector</text>
              <view className="DebugConsole-actions">
                <view
                  className="DebugConsole-button"
                  bindtap={() => setShowNetworkInspector(false)}
                >
                  <text className="DebugConsole-button-text">✕</text>
                </view>
              </view>
            </view>
            <NetworkInspector />
          </view>
        </view>
      )}
      {/* Sync Monitor Modal */}
      {showSyncMonitor && (
        <view
          className="DebugConsole-overlay"
          bindtap={() => setShowSyncMonitor(false)}
        >
          <view
            className="DebugConsole-modal"
            catchtap={() => {}}
            style={{ padding: 0, backgroundColor: 'transparent' }}
          >
            <view className="DebugConsole-header" style={{ marginBottom: 0 }}>
              <text className="DebugConsole-title">🔄 Sync Monitor</text>
              <view className="DebugConsole-actions">
                <view
                  className="DebugConsole-button"
                  bindtap={() => setShowSyncMonitor(false)}
                >
                  <text className="DebugConsole-button-text">✕</text>
                </view>
              </view>
            </view>
            <SyncMonitor />
          </view>
        </view>
      )}
      {/* State Inspector Modal */}
      {showStateInspector && (
        <view
          className="DebugConsole-overlay"
          bindtap={() => setShowStateInspector(false)}
        >
          <view
            className="DebugConsole-modal"
            catchtap={() => {}}
            style={{ padding: 0, backgroundColor: 'transparent' }}
          >
            <view className="DebugConsole-header" style={{ marginBottom: 0 }}>
              <text className="DebugConsole-title">💾 State Inspector</text>
              <view className="DebugConsole-actions">
                <view
                  className="DebugConsole-button"
                  bindtap={() => setShowStateInspector(false)}
                >
                  <text className="DebugConsole-button-text">✕</text>
                </view>
              </view>
            </view>
            <StateInspector />
          </view>
        </view>
      )}
    </>
  );
}


--------------------------------

FILE: components/ErrorBoundary.tsx
SIZE: 3.33 KB
TYPE: tsx

CONTENT:
import { Component, type ErrorInfo, type ReactNode } from 'react';
import { BUNDLE_COMMIT_HASH, BUNDLE_VERSION } from '../services/update';
import './ErrorBoundary.css';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallbackComponent?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

/**
 * ErrorBoundary catches JavaScript errors anywhere in the child component tree,
 * logs them, and displays a fallback UI instead of a blank screen.
 */
export class ErrorBoundary extends Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // Log error to console (captured by DebugLogService automatically)
    console.error('[ErrorBoundary] Caught error:', error.message);
    console.error('[ErrorBoundary] Stack:', error.stack || 'N/A');
    console.error(
      '[ErrorBoundary] Component Stack:',
      errorInfo.componentStack || 'N/A',
    );

    this.setState({ errorInfo });

    // Attempt to report to Supabase if available
    this.reportErrorToServer(error, errorInfo);
  }

  private async reportErrorToServer(
    error: Error,
    errorInfo: ErrorInfo,
  ): Promise<void> {
    try {
      const errorReport = {
        type: 'ERROR_BOUNDARY_CRASH',
        error: {
          message: error.message,
          stack: error.stack,
          componentStack: errorInfo.componentStack,
        },
        version: BUNDLE_VERSION,
        commit_hash: BUNDLE_COMMIT_HASH,
        timestamp: new Date().toISOString(),
      };

      // Log the error report (will be captured by DebugLogService)
      console.log(
        '[ErrorBoundary] Error report:',
        JSON.stringify(errorReport).substring(0, 500),
      );
    } catch (reportError) {
      console.error(
        '[ErrorBoundary] Failed to prepare error report:',
        reportError,
      );
    }
  }

  private handleReload = (): void => {
    // Reset state and attempt to re-render children
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    });
  };

  render(): ReactNode {
    if (this.state.hasError) {
      // Custom fallback component if provided
      if (this.props.fallbackComponent) {
        return this.props.fallbackComponent;
      }

      // Default fallback UI
      return (
        <view className="ErrorBoundary">
          <view className="ErrorBoundary-content">
            <text className="ErrorBoundary-icon">💔</text>
            <text className="ErrorBoundary-title">Something went wrong</text>
            <text className="ErrorBoundary-message">
              {this.state.error?.message || 'An unexpected error occurred.'}
            </text>
            <text className="ErrorBoundary-version">
              v{BUNDLE_VERSION} ({BUNDLE_COMMIT_HASH})
            </text>
            <view className="ErrorBoundary-button" bindtap={this.handleReload}>
              <text className="ErrorBoundary-button-text">Try Again</text>
            </view>
          </view>
        </view>
      );
    }

    return this.props.children;
  }
}


--------------------------------

FILE: components/HistoryView.tsx
SIZE: 4.32 KB
TYPE: tsx

CONTENT:
import { useEffect, useState } from '@lynx-js/react';
import { StorageService, type ViewedManga } from '../services/storage';
import type { Manga } from '../services/types';
import './HistoryView.css';

interface Props {
  onBack: () => void;
  onSelectHistoryItem: (
    manga: Manga,
    chapterUrl?: string,
    chapterTitle?: string,
  ) => void;
}

import { timeAgo } from '../utils/formatters';

export function HistoryView({ onBack, onSelectHistoryItem }: Props) {
  const [history, setHistory] = useState<ViewedManga[]>([]);
  const [loading, setLoading] = useState(true);
  const [latestUpdates, setLatestUpdates] = useState<Map<string, Manga>>(
    new Map(),
  );

  useEffect(() => {
    loadHistory();
    checkForNewChapters();
  }, []);

  const loadHistory = async () => {
    setLoading(true);
    try {
      const result = await StorageService.getHistory();
      setHistory(result.data);
    } catch (e) {
      console.error('[HistoryView] Failed to load:', e);
    } finally {
      setLoading(false);
    }
  };

  const checkForNewChapters = async () => {
    try {
      const updates = await StorageService.checkFavoritesForUpdates(false);
      setLatestUpdates(updates);
    } catch (e) {
      console.error('[HistoryView] Failed to check for updates:', e);
    }
  };

  const handleSelectManga = (item: ViewedManga) => {
    onSelectHistoryItem(item.manga, item.lastChapterId, item.lastChapterTitle);
  };

  return (
    <view className="HistoryView">
      <view className="HistoryView-header">
        <text className="HistoryView-back" bindtap={onBack}>
          ‹ Back
        </text>
        <text className="HistoryView-title">History</text>
        <view className="HistoryView-spacer" />
      </view>

      <scroll-view className="HistoryView-content" scroll-y>
        {loading ? (
          <view className="HistoryView-loading">
            <text className="HistoryView-loading-text">Loading history...</text>
          </view>
        ) : history.length === 0 ? (
          <view className="HistoryView-empty">
            <text className="HistoryView-empty-icon">📚</text>
            <text className="HistoryView-empty-title">No History Yet</text>
            <text className="HistoryView-empty-subtitle">
              Manga you read will appear here
            </text>
          </view>
        ) : (
          <view className="HistoryView-list">
            {history.map((item) => {
              const remoteManga = latestUpdates.get(item.manga.id);
              const hasUpdate = remoteManga
                ? StorageService.checkForUpdates(item.manga, remoteManga)
                : false;

              if (remoteManga) {
                console.log(
                  `[HistoryView] Item ${item.manga.title}: hasUpdate=${hasUpdate} (Remote: ${remoteManga.latestChapterUrl} vs Local: ${item.manga.latestChapterUrl})`,
                );
              }

              return (
                <view
                  key={item.manga.id}
                  className="HistoryView-item"
                  bindtap={() => handleSelectManga(item)}
                >
                  <image
                    src={item.manga.cover}
                    className="HistoryView-item-cover"
                    mode="aspectFill"
                  />
                  <view className="HistoryView-item-info">
                    <text className="HistoryView-item-title">
                      {item.manga.title}
                    </text>
                    <view className="HistoryView-item-meta">
                      {item.lastChapterTitle && (
                        <text className="HistoryView-item-chapter">
                          📖 {item.lastChapterTitle}
                        </text>
                      )}
                      {hasUpdate && (
                        <view className="HistoryView-item-badge-container">
                          <text className="HistoryView-item-badge">NEW</text>
                        </view>
                      )}
                    </view>
                    <text className="HistoryView-item-time">
                      {timeAgo(item.viewedAt)}
                    </text>
                  </view>
                  <text className="HistoryView-item-chevron">›</text>
                </view>
              );
            })}
          </view>
        )}
      </scroll-view>
    </view>
  );
}


--------------------------------

FILE: components/MangaCard.css
SIZE: 1.08 KB
TYPE: css

CONTENT:
/* Manga Card Component */
.MangaCard {
  display: flex;
  flex-direction: column;
}

.MangaCard-cover-container {
  position: relative;
  width: 100%;
}

.MangaCard-cover {
  width: 100%;
  aspect-ratio: 3 / 4;
  border-radius: 20px;
  overflow: hidden;
  border: 1px solid var(--accent-soft);
  background-color: var(--bg-main);
}

/* Favorite Button */
.MangaCard-favorite {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 36px;
  height: 36px;
  border-radius: 18px;
  background-color: rgba(0, 0, 0, 0.4);
  display: flex;
  align-items: center;
  justify-content: center;
}

.MangaCard-favorite.active {
  background-color: rgba(255, 255, 255, 0.9);
}

.MangaCard-favorite-icon {
  font-size: 18px;
}

.MangaCard-info {
  padding: 10px 2px 0 2px;
}

.MangaCard-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 2px;
  line-height: 1.3;
  overflow: hidden;
}

.MangaCard-chapter {
  font-size: 13px;
  color: var(--text-secondary);
  margin-bottom: 4px;
}

.MangaCard-genres {
  font-size: 11px;
  color: var(--text-accent);
  line-height: 1.4;
}


--------------------------------

FILE: components/MangaCard.tsx
SIZE: 2.11 KB
TYPE: tsx

CONTENT:
import { useEffect, useState } from '@lynx-js/react';
import { StorageService } from '../services/storage';
import type { Manga } from '../services/types';
import './MangaCard.css';

interface Props {
  manga: Manga;
  onSelect: (manga: Manga) => void;
  showFavoriteButton?: boolean;
}

export function MangaCard({
  manga,
  onSelect,
  showFavoriteButton = true,
}: Props) {
  const [isFavorite, setIsFavorite] = useState(
    StorageService.isFavoriteSync(manga.id),
  );
  const [loading, setLoading] = useState(false);

  // Check actual favorite status async
  useEffect(() => {
    StorageService.isFavorite(manga.id).then(setIsFavorite);
  }, [manga.id]);

  const handleToggleFavorite = async () => {
    if (loading) return;
    setLoading(true);

    try {
      if (isFavorite) {
        await StorageService.removeFavorite(manga.id);
        setIsFavorite(false);
      } else {
        await StorageService.addFavorite(manga);
        setIsFavorite(true);
      }
    } catch (e) {
      console.error('[MangaCard] Favorite toggle failed:', e);
    } finally {
      setLoading(false);
    }
  };

  return (
    <view className="MangaCard" bindtap={() => onSelect(manga)}>
      <view className="MangaCard-cover-container">
        <image
          src={manga.cover}
          className="MangaCard-cover"
          mode="aspectFill"
        />
        {showFavoriteButton && (
          <view
            className={
              isFavorite ? 'MangaCard-favorite active' : 'MangaCard-favorite'
            }
            catchtap={handleToggleFavorite}
          >
            <text className="MangaCard-favorite-icon">
              {loading ? '⏳' : isFavorite ? '❤️' : '🤍'}
            </text>
          </view>
        )}
      </view>
      <view className="MangaCard-info">
        <text className="MangaCard-title">{manga.title}</text>
        {manga.latestChapter && (
          <text className="MangaCard-chapter">{manga.latestChapter}</text>
        )}
        {manga.genres && manga.genres.length > 0 && (
          <text className="MangaCard-genres">{manga.genres.join(', ')}</text>
        )}
      </view>
    </view>
  );
}


--------------------------------

FILE: components/MangaDetailsUi.tsx
SIZE: 5.25 KB
TYPE: tsx

CONTENT:
import { useEffect, useMemo, useState } from '@lynx-js/react';
import { StorageService } from '../services/storage';
import type { MangaDetails } from '../services/types';
import './MangaDetailsUi.css';

interface Props {
  details: MangaDetails;
  onBack: () => void;
  onRead: (chapterUrl: string, chapterTitle?: string) => void;
}

export function MangaDetailsUi({ details, onBack, onRead }: Props) {
  const [descExpanded, setDescExpanded] = useState(false);
  const [reverseOrder, setReverseOrder] = useState(true);

  // Favorite state
  const [isFavorite, setIsFavorite] = useState(
    StorageService.isFavoriteSync(details.id),
  );
  const [favLoading, setFavLoading] = useState(false);

  useEffect(() => {
    StorageService.isFavorite(details.id).then(setIsFavorite);
  }, [details.id]);

  const handleToggleFavorite = async () => {
    if (favLoading) return;
    setFavLoading(true);
    try {
      if (isFavorite) {
        await StorageService.removeFavorite(details.id);
        setIsFavorite(false);
      } else {
        await StorageService.addFavorite({
          id: details.id,
          title: details.title,
          cover: details.cover,
          url: '', // Will be set by caller context
        });
        setIsFavorite(true);
      }
    } catch (e) {
      console.error('[MangaDetailsUi] Favorite toggle failed:', e);
    } finally {
      setFavLoading(false);
    }
  };

  // My wife can only read english, so we should only show english chapters.
  // For now, simple list with sort toggle.
  const displayChapters = useMemo(() => {
    const chapters = [...details.chapters];
    if (reverseOrder) {
      chapters.reverse();
    }
    return chapters;
  }, [details.chapters, reverseOrder]);

  return (
    <view className="DetailsContainer">
      {/* Header with blurred background? Or simple layout.. USER: We should do a header with blurred background */}
      <view className="DetailsHeader">
        <image
          className="DetailsBackdrop"
          src={details.cover}
          mode="aspectFill"
        />
        <view className="DetailsHeaderOverlay">
          <view className="HeaderNav">
            <text className="BackButton" bindtap={onBack}>
              ← Back
            </text>
            <view
              className={
                isFavorite ? 'DetailsFavorite active' : 'DetailsFavorite'
              }
              bindtap={handleToggleFavorite}
            >
              <text className="DetailsFavorite-icon">
                {favLoading ? '⏳' : isFavorite ? '❤️' : '🤍'}
              </text>
            </view>
          </view>
          <view className="HeaderContent">
            <image
              className="DetailsCover"
              src={details.cover}
              mode="aspectFill"
            />
            <view className="HeaderInfo">
              <text className="DetailsTitle">{details.title}</text>
              <view className="DetailsBadges">
                {details.status && (
                  <text className="Badge status">{details.status}</text>
                )}
                {details.rating && (
                  <text className="Badge rating">★ {details.rating}</text>
                )}
              </view>
              <text className="DetailsMeta">{details.authors?.join(', ')}</text>
              <text className="DetailsMeta">{details.views} views</text>
            </view>
          </view>
        </view>
      </view>

      <scroll-view className="DetailsBody" scroll-y>
        {/* Description */}
        <view
          className="DescriptionSection"
          bindtap={() => setDescExpanded(!descExpanded)}
        >
          <text
            className={
              descExpanded ? 'DescriptionText expanded' : 'DescriptionText'
            }
          >
            {details.description || 'No description available.'}
          </text>
          <text className="ExpandHint">
            {descExpanded ? 'Show less' : 'Read more'}
          </text>
        </view>

        {/* Genres, these need to be badges, but non intrusive. */}
        <scroll-view className="GenreRow" scroll-x>
          {details.genres?.map((g: string) => (
            <text key={g} className="GenreTag">
              {g}
            </text>
          ))}
        </scroll-view>

        {/* Chapters Actions */}
        <view className="ChapterActions">
          <text className="SectionTitle">
            {details.chapters.length} Chapters
          </text>
          <view
            className="SortButton"
            bindtap={() => setReverseOrder(!reverseOrder)}
          >
            <text className="SortText">
              {reverseOrder ? 'Oldest First' : 'Newest First'}
            </text>
          </view>
        </view>

        {/* Chapter List */}
        <view className="DetailsChapterList">
          {displayChapters.map((ch) => (
            <view
              key={ch.id}
              className="DetailChapterItem"
              bindtap={() => onRead(ch.url, ch.title)}
            >
              <view>
                <text className="ChTitle">{ch.title}</text>
                <text className="ChMeta">
                  {ch.group} • {ch.uploadDate}
                </text>
              </view>
            </view>
          ))}
        </view>
      </scroll-view>
    </view>
  );
}


--------------------------------

FILE: components/NetworkInspector.css
SIZE: 3.20 KB
TYPE: css

CONTENT:
.NetworkInspector {
  display: flex;
  flex-direction: column;
  height: 400px;
  background-color: var(--surface);
  border-radius: 8px;
  overflow: hidden;
  margin-top: 10px;
}

.NetworkInspector-header {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background-color: var(--glass);
  border-bottom: 1px solid var(--accent-border);
}

.NetworkInspector-title {
  color: var(--text-primary);
  font-weight: bold;
  font-size: 14px;
}

.NetworkInspector-btn {
  padding: 4px 8px;
  background-color: var(--accent-soft);
  border-radius: 4px;
}

.NetworkInspector-btn:active {
  background-color: var(--accent-border);
}

.NetworkInspector-btn-text {
  color: var(--text-accent);
  font-size: 12px;
  font-weight: bold;
}

.NetworkInspector-list {
  flex: 1;
  background-color: var(--bg-main);
}

.NetworkInspector-item {
  padding: 8px 12px;
  border-bottom: 1px solid var(--accent-border);
}

.NetworkInspector-item:active {
  background-color: var(--accent-soft);
}

.NetworkInspector-item.selected {
  background-color: var(--accent-soft);
  border-left: 3px solid var(--text-accent);
}

.NetworkInspector-item-row {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
}

.NetworkInspector-method {
  font-size: 11px;
  font-weight: bold;
  padding: 2px 4px;
  border-radius: 2px;
  color: #fff;
}

.NetworkInspector-method.GET {
  background-color: #0d47a1;
}

.NetworkInspector-method.POST {
  background-color: #1b5e20;
}

.NetworkInspector-status {
  font-size: 11px;
  font-weight: bold;
  color: var(--text-primary);
}

.NetworkInspector-duration {
  font-size: 10px;
  color: var(--text-secondary);
}

.NetworkInspector-url {
  font-size: 11px;
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.NetworkInspector-empty {
  color: var(--text-secondary);
  text-align: center;
  margin-top: 20px;
  font-size: 12px;
}

/* Details Overlay */
.NetworkInspector-details-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.NetworkInspector-details {
  width: 90%;
  height: 80%;
  background-color: var(--surface);
  border-radius: 8px;
  padding: 16px;
  display: flex;
  flex-direction: column;
  border: 1px solid var(--accent-border);
}

.NetworkInspector-details-header {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--accent-border);
}

.NetworkInspector-details-title {
  color: var(--text-primary);
  font-weight: bold;
  font-size: 16px;
}

.NetworkInspector-close {
  color: var(--text-secondary);
  font-size: 20px;
  padding: 4px;
}

.NetworkInspector-section {
  color: var(--text-accent);
  font-size: 12px;
  font-weight: bold;
  margin-top: 12px;
  margin-bottom: 4px;
}

.NetworkInspector-section.error {
  color: #ff5252;
}

.NetworkInspector-kv {
  color: var(--text-primary);
  font-size: 11px;
  margin-bottom: 4px;
  font-family: monospace;
}

.NetworkInspector-kv.error {
  color: #ff8a80;
}


--------------------------------

FILE: components/NetworkInspector.tsx
SIZE: 4.99 KB
TYPE: tsx

CONTENT:
import { useEffect, useState } from '@lynx-js/react';
import { NetworkLogService, type NetworkRequest } from '../services/networkLog';
import './NetworkInspector.css';

export function NetworkInspector() {
  const [logs, setLogs] = useState<NetworkRequest[]>([]);
  const [selectedId, setSelectedId] = useState<string | null>(null);

  useEffect(() => {
    setLogs(NetworkLogService.getLogs());
    const unsubscribe = NetworkLogService.subscribe(() => {
      setLogs(NetworkLogService.getLogs());
    });
    return () => {
      unsubscribe();
    };
  }, []);

  const handleClear = () => {
    NetworkLogService.clear();
    setSelectedId(null);
  };

  const selectedLog = logs.find((l) => l.id === selectedId);

  return (
    <view className="NetworkInspector">
      <view className="NetworkInspector-header">
        <text className="NetworkInspector-title">Network Traffic</text>
        <view className="NetworkInspector-actions">
          <view className="NetworkInspector-btn" bindtap={handleClear}>
            <text className="NetworkInspector-btn-text">Clear</text>
          </view>
        </view>
      </view>

      <view className="NetworkInspector-split">
        {/* Left: List */}
        <scroll-view className="NetworkInspector-list" scroll-y>
          {logs.map((log) => (
            <view
              key={log.id}
              className={`NetworkInspector-item ${selectedId === log.id ? 'selected' : ''}`}
              bindtap={() => setSelectedId(log.id)}
            >
              <view className="NetworkInspector-item-row">
                <text className={`NetworkInspector-method ${log.method}`}>
                  {log.method}
                </text>
                <text
                  className="NetworkInspector-status"
                  style={{
                    color:
                      log.status && log.status >= 400 ? '#ff5252' : '#4caf50',
                  }}
                >
                  {log.status || '...'}
                </text>
                <text className="NetworkInspector-duration">
                  {log.duration ? `${log.duration}ms` : ''}
                </text>
              </view>
              <text
                className="NetworkInspector-url"
                style={{
                  textOverflow: 'ellipsis',
                  overflow: 'hidden',
                  whiteSpace: 'nowrap',
                }}
              >
                {log.url}
              </text>
            </view>
          ))}
          {logs.length === 0 && (
            <text className="NetworkInspector-empty">No requests recorded</text>
          )}
        </scroll-view>

        {/* Right: Details (Inline for simple expansion or conditional) */}
        {/* For small screens, maybe just a modal? using split for now assuming dev mode often on tablet/desktop simulator or just scrollable */}
      </view>

      {selectedLog && (
        <view
          className="NetworkInspector-details-overlay"
          bindtap={() => setSelectedId(null)}
        >
          <scroll-view
            className="NetworkInspector-details"
            scroll-y
            catchtap={() => {}}
          >
            <view className="NetworkInspector-details-header">
              <text className="NetworkInspector-details-title">
                Request Details
              </text>
              <text
                className="NetworkInspector-close"
                bindtap={() => setSelectedId(null)}
              >
                ✕
              </text>
            </view>

            <text className="NetworkInspector-section">General</text>
            <text className="NetworkInspector-kv">URL: {selectedLog.url}</text>
            <text className="NetworkInspector-kv">
              Method: {selectedLog.method}
            </text>
            <text className="NetworkInspector-kv">
              Status: {selectedLog.status} {selectedLog.statusText}
            </text>
            <text className="NetworkInspector-kv">
              Duration: {selectedLog.duration}ms
            </text>

            <text className="NetworkInspector-section">Request Headers</text>
            {selectedLog.requestHeaders &&
              Object.entries(selectedLog.requestHeaders).map(([k, v]) => (
                <text key={k} className="NetworkInspector-kv">
                  {k}: {v}
                </text>
              ))}

            <text className="NetworkInspector-section">Response Headers</text>
            {selectedLog.responseHeaders &&
              Object.entries(selectedLog.responseHeaders).map(([k, v]) => (
                <text key={k} className="NetworkInspector-kv">
                  {k}: {v}
                </text>
              ))}

            {selectedLog.error && (
              <>
                <text className="NetworkInspector-section error">Error</text>
                <text className="NetworkInspector-kv error">
                  {selectedLog.error}
                </text>
              </>
            )}
          </scroll-view>
        </view>
      )}
    </view>
  );
}


--------------------------------

FILE: components/Reader.css
SIZE: 4.42 KB
TYPE: css

CONTENT:
.Reader {
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: #1a1a1a;
  width: 100%;
  height: 100%;
}

.Reader-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 110px;
  padding-top: 60px;
  background-color: rgba(26, 26, 26, 0.95);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding-left: 16px;
  padding-right: 16px;
  z-index: 100;
  transition:
    transform 0.3s ease,
    opacity 0.3s ease;
}

.Reader-header.hidden {
  transform: translateY(-110px);
  opacity: 0;
  pointer-events: none;
}

.Reader-header-left {
  width: 70px;
  display: flex;
  flex-direction: row;
  align-items: center;
}

.Reader-header-center {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  margin-left: 10px;
  margin-right: 10px;
}

.Reader-header-right {
  width: 70px;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: flex-end;
}

.Reader-header-title {
  color: #ffffff;
  font-size: 15px;
  font-weight: 600;
  text-align: center;
  width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.Reader-header-subtitle {
  color: rgba(255, 255, 255, 0.5);
  font-size: 11px;
  font-weight: 500;
  margin-top: 2px;
}

.Reader-back {
  color: #007aff;
  font-size: 17px;
  font-weight: 600;
  letter-spacing: -0.3px;
}

.Reader-content {
  flex: 1;
  width: 100%;
  padding-top: 110px;
  display: flex;
  flex-direction: column;
}

.Reader-loading-container {
  display: flex;
  flex: 1;
  align-items: center;
  justify-content: center;
  height: 300px;
}

.Reader-loading {
  color: rgba(255, 255, 255, 0.5);
  text-align: center;
  font-size: 16px;
  font-weight: 500;
}

.Reader-panel-container {
  width: 100%;
  background-color: #333; /* Loading indicator */
  /* aspect-ratio set dynamically via inline style */
}

.Reader-panel {
  width: 100%;
  height: 100%;
}

.Reader-panel-wrapper {
  width: 100%;
  position: relative;
  overflow: hidden;
}

.Reader-panel-loader {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
}

.Reader-panel-loader-text {
  color: #555;
  font-size: 12px;
}

.Reader-panel-error {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #2a2a2a;
}

.Reader-panel-error-text {
  color: #007aff;
  font-size: 14px;
  text-align: center;
  padding: 20px;
}

/* Favorite button in header */
.Reader-favorite-btn {
  font-size: 22px;
  transition: transform 0.15s ease;
}

.Reader-header-right:active .Reader-favorite-btn {
  transform: scale(1.2);
}

.Reader-footer-nav {
  width: 100%;
  padding: 60px 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: #111;
}

.Reader-next-btn {
  padding: 16px 32px;
  background-color: var(--text-accent);
  border-radius: 100px;
  box-shadow: var(--shadow-soft);
  transition:
    transform 0.2s ease,
    opacity 0.2s ease;
}

.Reader-next-btn:active {
  transform: scale(0.96);
  opacity: 0.9;
}

.Reader-next-text {
  color: #ffffff;
  font-size: 16px;
  font-weight: 700;
  letter-spacing: -0.3px;
}

/* Tap Zones */
.Reader-tap-zones {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: row;
  z-index: 50;
  pointer-events: none; /* Allow underlying content to be visible, but children will override */
}

.Reader-tap-zone {
  height: 100%;
  pointer-events: auto;
}

.Reader-tap-zone.prev {
  width: 25%;
}

.Reader-tap-zone.center {
  width: 50%;
}

.Reader-tap-zone.next {
  width: 25%;
}

.Reader-privacy-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  /* Discord-style "NSFW" blur effect (Fallback: Dark overlay since backdrop-filter is not supported) */
  background-color: rgba(20, 20, 20, 0.96); /* High opacity to hide content */
  z-index: 99; /* Below header (100) but above content */
  pointer-events: none; /* Allow clicks to pass through */
  transition: opacity 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Optional label to indicate why screen is blurry */
.Reader-privacy-overlay::after {
  content: "PRIVACY MODE";
  color: rgba(255, 255, 255, 0.3);
  font-weight: 900;
  font-size: 24px;
  letter-spacing: 2px;
}


--------------------------------

FILE: components/Reader.tsx
SIZE: 17.60 KB
TYPE: tsx

CONTENT:
import { useEffect, useRef, useState } from '@lynx-js/react';
import {
  BG_COLOR_DARK,
  DEFAULT_ASPECT_RATIO,
  KEY_DEBOUNCE_MS,
  MIN_PANEL_HEIGHT,
  PANEL_MAX_RETRIES,
  REMOTE_TOUCH_DIVIDER_X,
  RETRY_DELAY_BASE,
  RETRY_DELAY_INCREMENT,
  SWIPE_THRESHOLD_PX,
} from '../config';
import { logCapture } from '../services/debugLog';
import { SettingsStore } from '../services/settings';
import { sourceManager } from '../services/sourceManager';
import { normalizeUrl, StorageService } from '../services/storage';
import type { Manga } from '../services/types';
import './Reader.css';

// Helper for debug logging
const log = (...args: any[]) => logCapture('log', ...args);
const logError = (...args: any[]) => logCapture('error', ...args);

// Log immediately when Reader module loads
log('[Reader] ========== READER MODULE LOADED ==========');

interface Props {
  chapterUrl: string;
  chapterTitle?: string;
  manga?: Manga;
  onBack: () => void;
  hasNextChapter: boolean;
  onNextChapter: () => void;
}

function ReaderPanel({
  url,
  index,
  headers,
}: {
  url: string;
  index: number;
  headers?: Record<string, string>;
}) {
  const [ratio, setRatio] = useState<number | undefined>(undefined);
  const [retryCount, setRetryCount] = useState(0);
  const [failed, setFailed] = useState(false);

  const currentUrl =
    retryCount > 0
      ? `${url}${url.includes('?') ? '&' : '?'}retry=${retryCount}`
      : url;

  useEffect(() => {
    log(`[ReaderPanel #${index}] URL: ${currentUrl}`);
  }, [currentUrl, index]);

  // ... (rest of the component)

  const handleLoad = (e: any) => {
    const { width, height } = e.detail;
    const calcRatio = width / height;
    log(
      `[ReaderPanel #${index}] LOADED: ${width}x${height} (ratio: ${calcRatio.toFixed(3)})`,
    );
    if (width && height) {
      setRatio(calcRatio);
      setFailed(false);
    }
  };

  const handleError = (e: any) => {
    logError(
      `[ReaderPanel #${index}] ERROR (attempt ${retryCount + 1}/${PANEL_MAX_RETRIES}):`,
      e.detail?.errMsg,
    );
    if (retryCount < PANEL_MAX_RETRIES - 1) {
      setTimeout(
        () => {
          setRetryCount((prev) => prev + 1);
        },
        RETRY_DELAY_BASE + (index % 5) * RETRY_DELAY_INCREMENT,
      );
    } else {
      setFailed(true);
    }
  };

  const handleRetryTap = () => {
    if (retryCount >= PANEL_MAX_RETRIES - 1) {
      setRetryCount(0);
      setFailed(false);
    }
  };

  const displayRatio = ratio ? `${ratio}` : `${DEFAULT_ASPECT_RATIO}`;

  return (
    <view
      className="Reader-panel-wrapper"
      style={{
        aspectRatio: displayRatio,
        backgroundColor: ratio ? 'transparent' : BG_COLOR_DARK,
        minHeight: ratio ? 'auto' : MIN_PANEL_HEIGHT,
      }}
    >
      {/* Moved logic to ZoomOverlay wrapper in Reader */}
      {failed ? (
        <view className="Reader-panel-error" bindtap={handleRetryTap}>
          <text className="Reader-panel-error-text">
            Failed to load - Tap to retry
          </text>
        </view>
      ) : (
        <image
          src={currentUrl}
          className="Reader-panel"
          mode="scaleToFill"
          bindload={handleLoad}
          binderror={handleError}
          style={{ width: '100%', height: '100%' }}
        />
      )}

      {!ratio && !failed && (
        <view className="Reader-panel-loader">
          <text className="Reader-panel-loader-text">
            {retryCount > 0
              ? `Retrying (${retryCount}/${PANEL_MAX_RETRIES})...`
              : 'Loading...'}
          </text>
        </view>
      )}
    </view>
  );
}

//
// Removed ZoomOverlay and Wrapper
//

export function Reader({
  chapterUrl,
  chapterTitle,
  manga,
  onBack,
  hasNextChapter,
  onNextChapter,
}: Props) {
  log(
    '[Reader] COMPONENT RENDERING - chapterUrl:',
    chapterUrl?.substring(0, 50),
  );

  const [panels, setPanels] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [currentPage, setCurrentPage] = useState(0);
  const [restoredPageIndex, setRestoredPageIndex] = useState<
    number | undefined
  >(undefined);
  const [positionRestored, setPositionRestored] = useState(false);
  const [isRestoring, setIsRestoring] = useState(true);
  const [isFavorite, setIsFavorite] = useState(() =>
    manga ? StorageService.isFavoriteSync(manga.id) : false,
  );
  const [showControls, setShowControls] = useState(true);
  const [privacyFilter, setPrivacyFilter] = useState(
    SettingsStore.getPrivacyFilter(),
  );
  const [filterOpacity, setFilterOpacity] = useState(
    SettingsStore.getPrivacyFilterOpacity(),
  );
  // Removed zoomedUrl state

  const lastKeyDownTime = useRef<number>(0);
  const touchCount = useRef<number>(0);
  const lastTouchTime = useRef<number>(0);
  const touchResetTimer = useRef<NodeJS.Timeout>();

  useEffect(() => {
    const unsubscribe = SettingsStore.subscribe(() => {
      // Update settings
      setPrivacyFilter(SettingsStore.getPrivacyFilter());
      setFilterOpacity(SettingsStore.getPrivacyFilterOpacity());
    });
    return unsubscribe;
  }, []);

  const [headers, setHeaders] = useState<Record<string, string> | undefined>(
    undefined,
  );

  useEffect(() => {
    const loadPanels = async () => {
      setLoading(true);
      setIsRestoring(true);
      log('[Reader] Loading panels for:', chapterUrl);
      // Determine source from manga object if available, or try URL detection
      const sourceId = manga?.source;
      const source = sourceManager.resolveSource(sourceId || chapterUrl);

      // Extract headers from source if available
      if (source?.headers) {
        setHeaders(source.headers);
      }

      let urls: string[] = [];
      if (source) {
        urls = await source.getChapterPages(chapterUrl);
      } else {
        logError('[Reader] No source found for chapter:', chapterUrl);
      }
      log('[Reader] Received panels:', urls.length);
      setPanels(urls);

      if (manga) {
        const savedPosition = await StorageService.getReaderPositionForManga(
          manga.id,
        );

        if (
          savedPosition &&
          normalizeUrl(savedPosition.chapterUrl) === normalizeUrl(chapterUrl)
        ) {
          const restoredPage = Math.min(
            savedPosition.panelIndex,
            urls.length - 1,
          );
          log('[Reader] Found position to restore:', restoredPage);
          setCurrentPage(restoredPage);
          setRestoredPageIndex(restoredPage);
        } else {
          log('[Reader] No matching position found for this chapter');
          setCurrentPage(0);
          setRestoredPageIndex(0);
        }
      }

      setTimeout(() => {
        setPositionRestored(true);
        setIsRestoring(false);
        setLoading(false);
        log('[Reader] Restoration window closed. Tracking active.');
      }, 100);
    };
    loadPanels();
  }, [chapterUrl, manga?.id]);

  const handleTap = (e: any) => {
    const now = Date.now();

    // Reset count if too much time passed since last tap (300ms)
    if (now - lastTouchTime.current > 300) {
      touchCount.current = 0;
    }

    touchCount.current += 1;
    lastTouchTime.current = now;

    // Clear existing reset timer
    if (touchResetTimer.current) {
      clearTimeout(touchResetTimer.current);
    }

    if (touchCount.current === 3) {
      // TRIPLE TAP DETECTED
      log('[Reader] Triple tap detected - toggling privacy filter');
      SettingsStore.setPrivacyFilter(!privacyFilter);
      touchCount.current = 0; // Reset
      return;
    }

    // Set a timer to process single tap
    touchResetTimer.current = setTimeout(() => {
      if (touchCount.current === 1) {
        // Single Tap -> Toggle Controls
        toggleControls();
      }
      // Reset count
      touchCount.current = 0;
    }, 300);
  };

  const toggleControls = () => {
    setShowControls((prev) => !prev);
  };

  const scrollDown = (intensity = 1.0) => {
    // For vertical mode, we want to scroll down exactly one viewport height
    const runtime =
      typeof lynx !== 'undefined' ? lynx : (globalThis as any).lynx;
    if (runtime) {
      // SystemInfo dimensions are typically physical pixels, but scrollBy expects logical units (px/dp)
      const si =
        (globalThis as any).SystemInfo ||
        (typeof SystemInfo !== 'undefined' ? SystemInfo : null);
      const pixelRatio = si?.pixelRatio || 1;
      const screenHeightLogical = si?.screenHeight
        ? si.screenHeight / pixelRatio
        : 800;

      // Use user setting, but scale by intensity (e.g. 0.25 for keys => 15% screen)
      const baseSpeed = SettingsStore.getScrollSpeed();
      const scrollDistance = Math.floor(
        screenHeightLogical * baseSpeed * intensity,
      );

      log(
        `[Reader] Scroll DOWN: speed=${baseSpeed}, intensity=${intensity}, dist=${scrollDistance}`,
      );

      runtime
        .createSelectorQuery()
        .select('#reader-list')
        .invoke({
          method: 'scrollBy',
          params: {
            offset: scrollDistance,
            animated: true,
          },
        })
        .exec();
    }
  };

  const scrollUp = (intensity = 1.0) => {
    const runtime =
      typeof lynx !== 'undefined' ? lynx : (globalThis as any).lynx;
    if (runtime) {
      const si =
        (globalThis as any).SystemInfo ||
        (typeof SystemInfo !== 'undefined' ? SystemInfo : null);
      const pixelRatio = si?.pixelRatio || 1;
      const screenHeightLogical = si?.screenHeight
        ? si.screenHeight / pixelRatio
        : 800;

      const baseSpeed = SettingsStore.getScrollSpeed();
      const scrollDistance = Math.floor(
        screenHeightLogical * baseSpeed * intensity,
      );

      log(
        `[Reader] Scroll UP: speed=${baseSpeed}, intensity=${intensity}, dist=${scrollDistance}`,
      );

      runtime
        .createSelectorQuery()
        .select('#reader-list')
        .invoke({
          method: 'scrollBy',
          params: {
            offset: -scrollDistance,
            animated: true,
          },
        })
        .exec();
    }
  };

  const handleKeyDown = (e: any) => {
    // Throttle key events significantly to prevent over-scrolling/rapid page turns
    const now = Date.now();
    if (now - lastKeyDownTime.current < KEY_DEBOUNCE_MS) {
      log(`[Reader] Throttling KeyDown (${KEY_DEBOUNCE_MS}ms debounce)`);
      return;
    }
    lastKeyDownTime.current = now;

    // Handle both event structures (native override vs standard bindkeydown)
    const keyCode = e.keyCode || e.detail?.keyCode;
    log(`[Reader] KeyDown: ${keyCode}`);

    switch (keyCode) {
      case 19: // DPAD_UP
      case 21: // DPAD_LEFT
      case 24: // VOLUME_UP
        scrollUp(0.25); // 25% of normal speed (simulates lerp/smooth scroll)
        break;
      case 20: // DPAD_DOWN
      case 22: // DPAD_RIGHT
      case 25: // VOLUME_DOWN
        scrollDown(0.25); // 25% of normal speed
        break;
      case 23: // DPAD_CENTER
      case 66: // ENTER
      case 62: // SPACE
        toggleControls();
        break;
    }
  };

  // Listen for Native GlobalKeyEvents (from MainActivity.kt)
  useEffect(() => {
    log('[Reader] Setting up global event listeners...');

    // Get GlobalEventEmitter from Lynx
    let globalEventEmitter: any = null;
    try {
      if (typeof lynx !== 'undefined' && (lynx as any).getJSModule) {
        globalEventEmitter = (lynx as any).getJSModule('GlobalEventEmitter');
        log('[Reader] GlobalEventEmitter obtained:', !!globalEventEmitter);
      } else {
        log('[Reader] lynx.getJSModule not available');
      }
    } catch (e: any) {
      logError('[Reader] Failed to get GlobalEventEmitter:', e?.message);
    }

    const onGlobalKey = (data: any) => {
      log('[Reader] GlobalKeyEvent received:', JSON.stringify(data));

      // Handle both cases: data is the raw payload, or it's wrapped in an event object
      const payload = data?.data || data;
      let keyCode: number | undefined;

      if (Array.isArray(payload) && payload.length > 0) {
        keyCode = payload[0].keyCode;
      } else if (payload && typeof payload === 'object') {
        keyCode = payload.keyCode;
      } else if (typeof payload === 'number') {
        keyCode = payload;
      }

      if (keyCode) {
        log('[Reader] Processing Key:', keyCode);
        handleKeyDown({ keyCode });
      }
    };

    // Try to register with GlobalEventEmitter (correct Lynx API)
    if (globalEventEmitter && globalEventEmitter.addListener) {
      try {
        log('[Reader] Using GlobalEventEmitter.addListener...');
        globalEventEmitter.addListener('GlobalKeyEvent', onGlobalKey);
        // Removed GlobalTouchEvent listener to prevent conflict with screen touches
        log('[Reader] GlobalKeyEvent registered via GlobalEventEmitter!');
      } catch (e: any) {
        logError('[Reader] GlobalEventEmitter.addListener failed:', e?.message);
      }
    } else {
      log(
        '[Reader] GlobalEventEmitter not available, trying lynx.on fallback...',
      );
      // Fallback to lynx.on (older API)
      try {
        if (typeof lynx !== 'undefined' && (lynx as any).on) {
          (lynx as any).on('GlobalKeyEvent', onGlobalKey);
          // Removed GlobalTouchEvent listener
          log('[Reader] Registered via lynx.on fallback');
        } else {
          logError('[Reader] No event listening API available!');
        }
      } catch (e: any) {
        logError('[Reader] lynx.on fallback failed:', e?.message);
      }
    }

    return () => {
      if (globalEventEmitter && globalEventEmitter.removeListener) {
        globalEventEmitter.removeListener('GlobalKeyEvent', onGlobalKey);
      } else if (typeof lynx !== 'undefined' && (lynx as any).off) {
        (lynx as any).off('GlobalKeyEvent', onGlobalKey);
      }
    };
  }, [currentPage, panels.length]);

  // Save position when page changes (debounced)
  useEffect(() => {
    // CRITICAL: Block all saves until we are 100% sure we are in "tracking" mode
    if (
      isRestoring ||
      !positionRestored ||
      !manga ||
      loading ||
      panels.length === 0
    )
      return;

    const timeoutId = setTimeout(() => {
      log('[Reader] SYNCING: Saving current position:', currentPage);
      StorageService.saveReaderPosition(manga.id, chapterUrl, currentPage);
    }, 1000);

    return () => clearTimeout(timeoutId);
  }, [
    currentPage,
    manga,
    chapterUrl,
    loading,
    panels.length,
    positionRestored,
    isRestoring,
  ]);

  const handleToggleFavorite = async () => {
    if (!manga) return;
    if (isFavorite) {
      await StorageService.removeFavorite(manga.id);
      setIsFavorite(false);
    } else {
      await StorageService.addFavorite(manga);
      setIsFavorite(true);
    }
  };

  return (
    <view
      className="Reader"
      bindtap={handleTap}
      bindkeydown={handleKeyDown}
      focusable={true}
      focus-index="0"
    >
      <view className={showControls ? 'Reader-header' : 'Reader-header hidden'}>
        <view
          className="Reader-header-left"
          bindtap={onBack}
          style={{ padding: '10px 20px 10px 0' }}
        >
          {/* Expanded hit target */}
          <text className="Reader-back">{'‹ Back'}</text>
        </view>

        <view className="Reader-header-center">
          <text className="Reader-header-title">
            {chapterTitle || 'Reading Chapter'}
          </text>
          <text className="Reader-header-subtitle">
            {`${panels.length} panels total`}
          </text>
        </view>

        <view
          className="Reader-header-right"
          bindtap={handleToggleFavorite}
          style={{ padding: '10px 0 10px 20px' }}
        >
          {/* Favorite Toggle */}
          <text className="Reader-back">{isFavorite ? '❤️' : '🤍'}</text>
        </view>
      </view>

      <list
        id="reader-list"
        className="Reader-content"
        scroll-y
        initial-scroll-index={restoredPageIndex}
      >
        {loading ? (
          <list-item item-key="loading" full-span>
            <view className="Reader-loading-container">
              <text className="Reader-loading">Loading panels...</text>
            </view>
          </list-item>
        ) : panels.length === 0 ? (
          <list-item item-key="empty" full-span>
            <view className="Reader-loading-container">
              <text className="Reader-loading">No panels found</text>
            </view>
          </list-item>
        ) : (
          [
            ...panels.map((url, index) => (
              <list-item
                key={`panel-${index}`}
                item-key={`panel-${index}`}
                full-span
                binduiappear={() => {
                  // Only update currentPage if we are NOT in the middle of restoration
                  if (!isRestoring && !loading && positionRestored) {
                    setCurrentPage(index);
                  }
                }}
              >
                <ReaderPanel url={url} index={index} headers={headers} />
              </list-item>
            )),
            ...(hasNextChapter && onNextChapter
              ? [
                  <list-item
                    key="next-chapter"
                    item-key="next-chapter"
                    full-span
                  >
                    <view className="Reader-footer-nav">
                      <view className="Reader-next-btn" bindtap={onNextChapter}>
                        <text className="Reader-next-text">Next Chapter ›</text>
                      </view>
                    </view>
                  </list-item>,
                ]
              : []),
          ]
        )}
      </list>

      {/* Privacy Overlay */}
      {privacyFilter && (
        <view
          className="Reader-privacy-overlay"
          style={{ opacity: filterOpacity }}
        />
      )}
    </view>
  );
}


--------------------------------

FILE: components/Settings.css
SIZE: 9.04 KB
TYPE: css

CONTENT:
/* Settings Page - Lumina Design System */
.Settings {
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: var(--bg-main);
  width: 100%;
  height: 100%;
}

.Settings-header {
  padding: 50px 24px 16px 24px;
  background-color: var(--glass);
}

.Settings-title {
  font-size: 28px;
  font-weight: 800;
  letter-spacing: -0.5px;
  color: var(--text-accent);
}

.Settings-content {
  flex: 1;
  padding: 16px 24px 100px 24px;
}

.Settings-section {
  margin-bottom: 24px;
}

.Settings-section-title {
  font-size: 13px;
  font-weight: 700;
  color: var(--text-secondary);
  letter-spacing: 0.5px;
  margin-bottom: 12px;
}

.Settings-item {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 16px;
  background-color: var(--surface);
  border: 1px solid var(--accent-border);
  border-radius: 16px;
  margin-bottom: 8px;
  box-shadow: var(--shadow-soft);
}

.Settings-item-left {
  display: flex;
  flex-direction: row;
  align-items: center;
  flex: 1;
}

.Settings-item-icon {
  font-size: 24px;
  margin-right: 14px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--accent-soft);
  border-radius: 8px;
}

.Settings-item-text {
  display: flex;
  flex-direction: column;
}

.Settings-item-label {
  font-size: 16px;
  font-weight: 600;
  color: var(--text-primary);
}

.Settings-item-description {
  font-size: 13px;
  color: var(--text-secondary);
  margin-top: 2px;
}

.Settings-item-chevron {
  font-size: 20px;
  color: var(--text-secondary);
  font-weight: 300;
}

/* Scroll Speed Buttons */
.Settings-speed-buttons {
  display: flex;
  flex-direction: row;
  gap: 8px;
}

.Settings-speed-btn {
  width: 36px;
  height: 36px;
  border-radius: 18px;
  background-color: var(--accent-border);
  display: flex;
  align-items: center;
  justify-content: center;
}

.Settings-speed-btn text {
  font-size: 12px;
  font-weight: 700;
  color: var(--text-secondary);
}

.Settings-speed-btn.active {
  background-color: var(--text-accent);
}

.Settings-speed-btn.active text {
  color: #000;
}

/* Footer */
.Settings-footer {
  padding: 24px;
  align-items: center;
}

.Settings-footer-text {
  font-size: 13px;
  color: var(--text-secondary);
  text-align: center;
}

.Settings-footer-heart {
  font-size: 13px;
  color: var(--text-accent);
}

/* Toggle Switch */
.Settings-toggle {
  width: 50px;
  height: 30px;
  background-color: var(--accent-border);
  border-radius: 15px;
  padding: 3px;
  display: flex;
  align-items: center;
}

.Settings-toggle.active {
  background-color: var(--text-accent);
  justify-content: flex-end;
}

.Settings-toggle-knob {
  width: 24px;
  height: 24px;
  background-color: white;
  border-radius: 12px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

/* Danger Item */
.Settings-item.danger .Settings-item-label {
  color: #e74c3c;
}

.Settings-item.danger .Settings-item-description {
  color: #e74c3c;
  opacity: 0.7;
}

/* Confirmation Dialog Overlay */
.ConfirmOverlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 24px;
}

.ConfirmDialog {
  background-color: var(--surface);
  border-radius: 20px;
  padding: 24px;
  width: 100%;
  max-width: 320px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

.ConfirmTitle {
  font-size: 18px;
  font-weight: 700;
  color: var(--text-primary);
  text-align: center;
  margin-bottom: 12px;
}

.ConfirmMessage {
  font-size: 14px;
  color: var(--text-secondary);
  text-align: center;
  line-height: 1.4;
  margin-bottom: 24px;
}

.ConfirmActions {
  display: flex;
  flex-direction: row;
}

.ConfirmButton {
  flex: 1;
  padding: 14px 20px;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 6px;
}

.ConfirmButton.cancel {
  background-color: var(--accent-soft);
}

.ConfirmButton.danger {
  background-color: #e74c3c;
}

.ConfirmButtonText {
  font-size: 15px;
  font-weight: 600;
  color: var(--text-primary);
  text-align: center;
}

.ConfirmButton.danger .ConfirmButtonText {
  color: white;
}

.Settings-card {
  display: flex;
  flex-direction: column;
  padding: 16px;
  background-color: var(--surface);
  /* Ensure opaque background to prevent ghosting */
  border: 1px solid var(--accent-border);
  border-radius: 20px;
  margin-bottom: 12px;
  box-shadow: var(--shadow-soft);
}

.Settings-card > .Settings-item-left {
  align-items: flex-start;
}

.Settings-input-group {
  display: flex;
  flex-direction: row;
  align-items: center;
  margin-bottom: 16px;
  width: 100%;
}

.Settings-input-label {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 8px;
}

.Settings-input {
  /* @ts-ignore for Lynx input */
  flex: 1;
  background-color: rgba(128, 128, 128, 0.15);
  color: var(--text-primary);
  padding: 12px 16px;
  border-radius: 12px;
  font-size: 14px;
  border: 1px solid var(--accent-border);
  min-height: 48px;
}

.Settings-input-inline {
  flex: 1;
  background-color: transparent;
  color: var(--text-primary);
  padding: 0;
  font-size: 16px;
  font-weight: 600;
  border: none;
  min-height: 24px;
}

.Settings-button-row {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: flex-end;
  gap: 12px;
  width: 100%;
}

.Settings-button {
  height: 40px;
  min-width: 80px;
  padding: 0 16px;
  border-radius: 12px;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  border: 1px solid transparent;
  flex: 0 0 auto;
  /* Prevent shrinking */
}

.Settings-button.primary {
  background-color: #d47a94;
}

.Settings-button.danger {
  background-color: rgba(231, 76, 60, 0.1);
  border-color: rgba(231, 76, 60, 0.2);
}

.Settings-button-text {
  font-size: 13px;
  font-weight: 700;
  color: #d47a94;
}

.Settings-button.primary .Settings-button-text {
  color: #ffffff;
}

.Settings-button.danger .Settings-button-text {
  color: #e74c3c;
}

.Settings-button.disabled {
  opacity: 0.5;
}

/* Debug Console Modal - Lumina Redesign */

.DebugConsole-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.4);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  padding: 16px;
}

.DebugConsole-modal {
  background-color: var(--surface);
  border-radius: 24px;
  width: 100%;
  height: 85%;
  max-width: 600px;
  display: flex;
  flex-direction: column;
  box-shadow: 0 30px 100px rgba(0, 0, 0, 0.2);
  border: 1px solid var(--accent-border);
  overflow: hidden;
}

.DebugConsole-header {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  background-color: var(--glass);
  border-bottom: 1px solid var(--accent-border);
}

.DebugConsole-title {
  font-size: 20px;
  font-weight: 800;
  color: var(--text-accent);
  letter-spacing: -0.5px;
}

.DebugConsole-actions {
  display: flex;
  flex-direction: row;
  gap: 12px;
}

.DebugConsole-toolbar {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 12px;
  padding: 12px 24px;
  background-color: var(--glass);
  border-bottom: 1px solid var(--accent-border);
}

.DebugConsole-button {
  width: 40px;
  height: 40px;
  background-color: var(--accent-soft);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.DebugConsole-button.primary {
  width: auto;
  padding: 0 16px;
  background-color: var(--text-accent);
}

.DebugConsole-button-text {
  font-size: 14px;
  color: var(--text-accent);
  font-weight: 700;
}

.DebugConsole-button.primary .DebugConsole-button-text {
  color: #ffffff;
}

.DebugConsole-status {
  padding: 10px 24px;
  background-color: var(--accent-soft);
  border-bottom: 1px solid var(--accent-border);
}

.DebugConsole-status-text {
  font-size: 13px;
  color: var(--text-accent);
  font-weight: 600;
  text-align: center;
}

.DebugConsole-content {
  flex: 1;
  background-color: #1e1e1e;
  /* Force dark background for logs */
  padding: 16px;
}

.DebugConsole-text {
  font-family: "Consolas", "Monaco", "Courier New", monospace;
  font-size: 11px;
  color: #e0e0e0;
  line-height: 1.5;
  white-space: pre-wrap;
  word-break: break-all;
}

.RestoreInput {
  flex: 1;
  background-color: var(--bg-main);
  border: 1px solid var(--accent-border);
  border-radius: 12px;
  padding: 0 12px;
  height: 44px;
  color: var(--text-primary);
  font-size: 14px;
}

.RestoreButton {
  min-width: 80px;
  height: 44px;
  padding: 0 16px;
  background-color: var(--text-accent);
  border-radius: 12px;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  box-shadow: var(--shadow-soft);
  margin-left: 8px;
}

.RestoreButton.secondary {
  min-width: 44px;
  width: 44px;
  padding: 0;
  background-color: var(--surface);
  border: 1px solid var(--accent-border);
}

.RestoreRow {
  display: flex;
  flex-direction: row;
  align-items: center;
  width: 100%;
  margin-top: 12px;
}

.RestoreButtonText {
  color: white;
  font-size: 14px;
  font-weight: 700;
}


--------------------------------

FILE: components/Settings.tsx
SIZE: 11.24 KB
TYPE: tsx

CONTENT:
import { useEffect, useState } from '@lynx-js/react';
import { SettingsStore } from '../services/settings';
import { StorageService } from '../services/storage';
import { BUNDLE_VERSION } from '../services/update';
import { DeveloperOptions } from './DeveloperOptions';
import './Settings.css';

interface Props {
  onBack?: () => void;
  onNavigate?: (view: 'favorites' | 'history') => void;
}

export function Settings({ onBack, onNavigate }: Props) {
  const [darkMode, setDarkMode] = useState(SettingsStore.getDarkMode());
  const [devMode, setDevMode] = useState(SettingsStore.getDevMode());
  const [scrollSpeed, setScrollSpeed] = useState(
    SettingsStore.getScrollSpeed(),
  );

  const [historyCount, setHistoryCount] = useState(0);
  const [favoritesCount, setFavoritesCount] = useState(0);
  const [showClearConfirm, setShowClearConfirm] = useState<
    'history' | 'all' | null
  >(null);

  // Developer mode tap counter
  const [aboutTaps, setAboutTaps] = useState(0);

  useEffect(() => {
    const unsubscribe = SettingsStore.subscribe(() => {
      setDarkMode(SettingsStore.getDarkMode());
      setDevMode(SettingsStore.getDevMode());
      setScrollSpeed(SettingsStore.getScrollSpeed());
      setScrollSpeed(SettingsStore.getScrollSpeed());
    });

    // Load counts
    StorageService.getHistory().then((h) => setHistoryCount(h.data.length));
    StorageService.getFavorites().then((f) => setFavoritesCount(f.data.length));

    return unsubscribe;
  }, []);

  // Version info
  const [nativeVersion, setNativeVersion] = useState<string>('Loading...');

  useEffect(() => {
    // Fetch native version from module
    try {
      if (
        typeof NativeModules !== 'undefined' &&
        NativeModules.NativeUpdaterModule
      ) {
        const v = NativeModules.NativeUpdaterModule.getNativeVersion();
        setNativeVersion(v);
      } else {
        setNativeVersion('N/A (Web)');
      }
    } catch (e) {
      setNativeVersion('Error');
    }
  }, []);

  const handleDarkModeToggle = () => {
    SettingsStore.setDarkMode(!darkMode);
  };

  const handleScrollSpeedChange = (speed: number) => {
    SettingsStore.setScrollSpeed(speed);
  };

  const handleAboutTap = () => {
    const newTaps = aboutTaps + 1;
    if (newTaps >= 5) {
      const newState = !devMode;
      SettingsStore.setDevMode(newState);
      setAboutTaps(0);
      console.log(
        `[Settings] Developer mode ${newState ? 'activated' : 'deactivated'}!`,
      );
    } else {
      setAboutTaps(newTaps);
    }
  };

  const handleClearHistory = async () => {
    await StorageService.clearHistory();
    setHistoryCount(0);
    setShowClearConfirm(null);
  };

  const handleClearAll = async () => {
    await StorageService.clearAllData();
    setHistoryCount(0);
    setFavoritesCount(0);
    setShowClearConfirm(null);
  };

  return (
    <view className="Settings">
      <view className="Settings-header">
        <text className="Settings-title">Settings</text>
      </view>

      <scroll-view className="Settings-content" scroll-y>
        {/* Reading Section */}
        <view className="Settings-section">
          <text className="Settings-section-title">READING</text>

          {/* Scroll Speed Setting */}
          <view className="Settings-item">
            <view className="Settings-item-left">
              <text className="Settings-item-icon">⚡</text>
              <view className="Settings-item-text">
                <text className="Settings-item-label">Scroll Speed</text>
                <text className="Settings-item-description">
                  {scrollSpeed <= 0.4
                    ? 'Slow'
                    : scrollSpeed <= 0.6
                      ? 'Normal'
                      : scrollSpeed <= 0.8
                        ? 'Fast'
                        : 'Very Fast'}{' '}
                  ({Math.round(scrollSpeed * 100)}%)
                </text>
              </view>
            </view>
            <view className="Settings-speed-buttons">
              <view
                className={
                  scrollSpeed === 0.4
                    ? 'Settings-speed-btn active'
                    : 'Settings-speed-btn'
                }
                bindtap={() => handleScrollSpeedChange(0.4)}
              >
                <text>S</text>
              </view>
              <view
                className={
                  scrollSpeed === 0.6
                    ? 'Settings-speed-btn active'
                    : 'Settings-speed-btn'
                }
                bindtap={() => handleScrollSpeedChange(0.6)}
              >
                <text>N</text>
              </view>
              <view
                className={
                  scrollSpeed === 0.8
                    ? 'Settings-speed-btn active'
                    : 'Settings-speed-btn'
                }
                bindtap={() => handleScrollSpeedChange(0.8)}
              >
                <text>F</text>
              </view>
              <view
                className={
                  scrollSpeed === 1.0
                    ? 'Settings-speed-btn active'
                    : 'Settings-speed-btn'
                }
                bindtap={() => handleScrollSpeedChange(1.0)}
              >
                <text>VF</text>
              </view>
            </view>
          </view>
        </view>

        {/* Appearance Section */}
        <view className="Settings-section">
          <text className="Settings-section-title">APPEARANCE</text>

          <view className="Settings-item" bindtap={handleDarkModeToggle}>
            <view className="Settings-item-left">
              <text className="Settings-item-icon">
                {darkMode ? '🌙' : '☀️'}
              </text>
              <view className="Settings-item-text">
                <text className="Settings-item-label">Dark Mode</text>
                <text className="Settings-item-description">
                  {darkMode ? 'Enabled' : 'Disabled'}
                </text>
              </view>
            </view>
            <view
              className={
                darkMode ? 'Settings-toggle active' : 'Settings-toggle'
              }
            >
              <view className="Settings-toggle-knob" />
            </view>
          </view>
        </view>

        {/* Library Section */}
        <view className="Settings-section">
          <text className="Settings-section-title">LIBRARY</text>

          <view
            className="Settings-item"
            bindtap={() => onNavigate?.('favorites')}
          >
            <view className="Settings-item-left">
              <text className="Settings-item-icon">❤️</text>
              <view className="Settings-item-text">
                <text className="Settings-item-label">Favorites</text>
                <text className="Settings-item-description">
                  {favoritesCount} manga saved
                </text>
              </view>
            </view>
            <text className="Settings-item-chevron">›</text>
          </view>

          <view
            className="Settings-item"
            bindtap={() => onNavigate?.('history')}
          >
            <view className="Settings-item-left">
              <text className="Settings-item-icon">📚</text>
              <view className="Settings-item-text">
                <text className="Settings-item-label">Reading History</text>
                <text className="Settings-item-description">
                  {historyCount} manga viewed
                </text>
              </view>
            </view>
            <text className="Settings-item-chevron">›</text>
          </view>
        </view>

        {/* Data Management */}
        <view className="Settings-section">
          <text className="Settings-section-title">DATA</text>

          <view
            className="Settings-item"
            bindtap={() => setShowClearConfirm('history')}
          >
            <view className="Settings-item-left">
              <text className="Settings-item-icon">🗑️</text>
              <view className="Settings-item-text">
                <text className="Settings-item-label">Clear History</text>
                <text className="Settings-item-description">
                  Remove all reading history
                </text>
              </view>
            </view>
            <text className="Settings-item-chevron">›</text>
          </view>

          <view
            className="Settings-item danger"
            bindtap={() => setShowClearConfirm('all')}
          >
            <view className="Settings-item-left">
              <text className="Settings-item-icon">⚠️</text>
              <view className="Settings-item-text">
                <text className="Settings-item-label">Clear All Data</text>
                <text className="Settings-item-description">
                  Remove favorites, history, and settings
                </text>
              </view>
            </view>
            <text className="Settings-item-chevron">›</text>
          </view>
        </view>

        {/* About Section */}
        <view className="Settings-section">
          <text className="Settings-section-title">ABOUT</text>

          <view className="Settings-item" bindtap={handleAboutTap}>
            <view className="Settings-item-left">
              <text className="Settings-item-icon">💜</text>
              <view className="Settings-item-text">
                <text className="Settings-item-label">SMUTHUB</text>
                <text className="Settings-item-description">
                  APK: v{nativeVersion}
                </text>
                <text className="Settings-item-description">
                  JS: v{BUNDLE_VERSION}
                </text>
                <text className="Settings-item-description">🖤 Daddy..</text>
              </view>
            </view>
          </view>
          {/* Developer Section */}
          {devMode && <DeveloperOptions />}
        </view>
      </scroll-view>

      {/* Confirmation Dialog */}
      {showClearConfirm && (
        <view
          className="ConfirmOverlay"
          bindtap={() => setShowClearConfirm(null)}
        >
          <view className="ConfirmDialog" catchtap={() => {}}>
            <text className="ConfirmTitle">
              {showClearConfirm === 'history'
                ? 'Clear History?'
                : 'Clear All Data?'}
            </text>
            <text className="ConfirmMessage">
              {showClearConfirm === 'history'
                ? 'This will remove all your reading history. This cannot be undone.'
                : 'This will remove all favorites, history, and settings. This cannot be undone.'}
            </text>
            <view className="ConfirmActions">
              <view
                className="ConfirmButton cancel"
                bindtap={() => setShowClearConfirm(null)}
              >
                <text className="ConfirmButtonText">Cancel</text>
              </view>
              <view
                className="ConfirmButton danger"
                bindtap={
                  showClearConfirm === 'history'
                    ? handleClearHistory
                    : handleClearAll
                }
              >
                <text className="ConfirmButtonText">Clear</text>
              </view>
            </view>
          </view>
        </view>
      )}
    </view>
  );
}


--------------------------------

FILE: components/Sparkles.tsx
SIZE: 2.26 KB
TYPE: tsx

CONTENT:
import { type ReactNode, useEffect, useState } from '@lynx-js/react';
import { ACTIVE_EVENT } from '../config';
import './Sparkles.css';

interface Sparkle {
  id: string;
  createdAt: number;
  color: string;
  size: number;
  style: any;
  icon: string;
  mode: 'sparkle' | 'fall' | 'drift';
}

const generateSparkle = (
  color: string,
  icon: string,
  mode: 'sparkle' | 'fall' | 'drift' = 'sparkle',
): Sparkle => {
  const isFall = mode === 'fall';

  return {
    id: Math.random().toString(36).slice(2),
    createdAt: Date.now(),
    color,
    size: Math.floor(Math.random() * 20) + 15,
    style: {
      top: isFall ? '-40px' : Math.floor(Math.random() * 100) + '%',
      left: Math.floor(Math.random() * 100) + '%',
      zIndex: 2,
    },
    icon,
    mode,
  };
};

interface Props {
  color?: string;
  icon?: string;
  mode?: 'sparkle' | 'fall' | 'drift';
  children: ReactNode;
  enabled?: boolean;
}

export const Sparkles = ({
  color = ACTIVE_EVENT.color,
  icon = ACTIVE_EVENT.icon,
  mode = ACTIVE_EVENT.mode as any,
  children,
  enabled = ACTIVE_EVENT.enabled,
}: Props) => {
  const [sparkles, setSparkles] = useState<Sparkle[]>([]);

  useEffect(() => {
    if (!enabled) {
      setSparkles([]);
      return;
    }

    const interval = setInterval(
      () => {
        const now = Date.now();
        const newSparkle = generateSparkle(color, icon, mode);

        setSparkles((current) => {
          const lifetime =
            mode === 'fall' ? 3000 : mode === 'drift' ? 2000 : 750;
          const filtered = current.filter((s) => now - s.createdAt < lifetime);

          if (filtered.length >= 12) return filtered;
          return [...filtered, newSparkle];
        });
      },
      mode === 'sparkle' ? 400 : 800,
    );

    return () => clearInterval(interval);
  }, [enabled, color, icon, mode]);

  return (
    <view className="SparklesWrapper">
      {sparkles.map((sparkle) => (
        <text
          key={sparkle.id}
          className={`SparkleInstance mode-${sparkle.mode}`}
          style={{
            ...sparkle.style,
            fontSize: sparkle.size + 'px',
            color: sparkle.color,
          }}
        >
          {sparkle.icon}
        </text>
      ))}
      <view className="SparkleChildWrapper">{children}</view>
    </view>
  );
};


--------------------------------

FILE: components/StateInspector.css
SIZE: 3.10 KB
TYPE: css

CONTENT:
.StateInspector {
  display: flex;
  flex-direction: column;
  height: 400px;
  background-color: var(--surface);
  border-radius: 8px;
  overflow: hidden;
}

.StateInspector-header {
  padding: 12px;
  background-color: var(--glass);
  border-bottom: 1px solid var(--accent-border);
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
}

.StateInspector-title {
  color: var(--text-primary);
  font-weight: bold;
  font-size: 16px;
}

.StateInspector-actions {
  display: flex;
  flex-direction: row;
}

.StateInspector-btn {
  padding: 6px 12px;
  border-radius: 4px;
  margin-left: 8px;
  background-color: var(--accent-soft);
}

.StateInspector-btn.primary {
  background-color: var(--text-accent);
}

.StateInspector-btn.danger {
  background-color: #d32f2f;
}

.StateInspector-btn.small {
  padding: 4px 8px;
  margin-left: 0;
}

.StateInspector-btn:active {
  opacity: 0.8;
}

.StateInspector-btn-text {
  color: var(--text-accent);
  font-size: 12px;
  font-weight: bold;
}

.StateInspector-btn.primary .StateInspector-btn-text,
.StateInspector-btn.danger .StateInspector-btn-text {
  color: #fff;
}

.StateInspector-split {
  flex: 1;
  position: relative;
}

.StateInspector-list {
  flex: 1;
  background-color: var(--bg-main);
  padding: 8px;
  height: 100%;
}

.StateInspector-item {
  background-color: var(--surface);
  border-radius: 4px;
  padding: 10px;
  margin-bottom: 8px;
  border: 1px solid var(--accent-border);
}

.StateInspector-item.selected {
  border-color: var(--text-accent);
  background-color: var(--accent-soft);
}

.StateInspector-item-row {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
}

.StateInspector-key {
  color: var(--text-primary);
  font-weight: bold;
  font-size: 14px;
}

.StateInspector-size {
  color: var(--text-secondary);
  font-size: 10px;
  font-family: monospace;
}

.StateInspector-empty-label {
  color: var(--text-secondary);
  font-size: 10px;
  font-style: italic;
}

.StateInspector-raw-key {
  color: var(--text-secondary);
  font-size: 10px;
  font-family: monospace;
}

.StateInspector-detail-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
}

.StateInspector-detail-modal {
  background-color: var(--surface);
  border-radius: 8px;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  border: 1px solid var(--accent-border);
  overflow: hidden;
}

.StateInspector-detail-header {
  padding: 10px;
  background-color: var(--glass);
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--accent-border);
}

.StateInspector-detail-title {
  color: var(--text-primary);
  font-weight: bold;
  font-size: 14px;
}

.StateInspector-detail-content {
  flex: 1;
  padding: 10px;
  background-color: var(--bg-main);
}

.StateInspector-json {
  color: var(--text-primary);
  font-family: monospace;
  font-size: 12px;
  white-space: pre-wrap;
}


--------------------------------

FILE: components/StateInspector.tsx
SIZE: 3.75 KB
TYPE: tsx

CONTENT:
import { useEffect, useState } from '@lynx-js/react';
import { STORAGE_KEYS, StorageService } from '../services/storage';
import './StateInspector.css';

export function StateInspector() {
  const [state, setState] = useState<Record<string, any>>({});
  const [selectedKey, setSelectedKey] = useState<string | null>(null);

  const refresh = () => {
    setState(StorageService.getMemoryState());
  };

  useEffect(() => {
    refresh();
  }, []);

  const handleClearKey = async (key: string) => {
    // eslint-disable-next-line no-restricted-globals
    // confirm or just do it? Dev tool implies power user.
    await StorageService.clearKey(key);
    refresh();
    if (selectedKey === key) setSelectedKey(null);
  };

  const handleClearAll = async () => {
    await StorageService.clearAllData();
    refresh();
    setSelectedKey(null);
  };

  const getKeyLabel = (key: string) => {
    const entry = Object.entries(STORAGE_KEYS).find(([_, v]) => v === key);
    return entry ? entry[0] : key.replace('batoto:', '');
  };

  const selectedValue = selectedKey ? state[selectedKey] : null;

  return (
    <view className="StateInspector">
      <view className="StateInspector-header">
        <text className="StateInspector-title">Local Storage</text>
        <view className="StateInspector-actions">
          <view className="StateInspector-btn danger" bindtap={handleClearAll}>
            <text className="StateInspector-btn-text">Reset All Data</text>
          </view>
          <view className="StateInspector-btn primary" bindtap={refresh}>
            <text className="StateInspector-btn-text">Refresh</text>
          </view>
        </view>
      </view>

      <view className="StateInspector-split">
        <scroll-view className="StateInspector-list" scroll-y>
          {Object.keys(STORAGE_KEYS).map((k) => {
            const key = STORAGE_KEYS[k as keyof typeof STORAGE_KEYS];
            const hasValue = state[key] !== undefined;
            const size = hasValue ? JSON.stringify(state[key]).length : 0;

            return (
              <view
                key={key}
                className={`StateInspector-item ${selectedKey === key ? 'selected' : ''}`}
                bindtap={() => setSelectedKey(key)}
              >
                <view className="StateInspector-item-row">
                  <text className="StateInspector-key">{k}</text>
                  {hasValue ? (
                    <text className="StateInspector-size">{size}b</text>
                  ) : (
                    <text className="StateInspector-empty-label">Empty</text>
                  )}
                </view>
                <text className="StateInspector-raw-key">{key}</text>
              </view>
            );
          })}
        </scroll-view>

        {selectedKey && (
          <view
            className="StateInspector-detail-overlay"
            bindtap={() => setSelectedKey(null)}
          >
            <view className="StateInspector-detail-modal" catchtap={() => {}}>
              <view className="StateInspector-detail-header">
                <text className="StateInspector-detail-title">
                  {getKeyLabel(selectedKey)}
                </text>
                <view
                  className="StateInspector-btn danger small"
                  bindtap={() => handleClearKey(selectedKey)}
                >
                  <text className="StateInspector-btn-text">Delete</text>
                </view>
              </view>
              <scroll-view className="StateInspector-detail-content" scroll-y>
                <text className="StateInspector-json">
                  {JSON.stringify(selectedValue, null, 2) || 'null'}
                </text>
              </scroll-view>
            </view>
          </view>
        )}
      </view>
    </view>
  );
}


--------------------------------

FILE: components/SyncMonitor.css
SIZE: 2.64 KB
TYPE: css

CONTENT:
.SyncMonitor {
  display: flex;
  flex-direction: column;
  height: 400px;
  background-color: var(--surface);
  border-radius: 8px;
  overflow: hidden;
}

.SyncMonitor-header {
  padding: 12px;
  background-color: var(--glass);
  border-bottom: 1px solid var(--accent-border);
}

.SyncMonitor-status-row {
  display: flex;
  flex-direction: row;
  align-items: center;
  margin-bottom: 8px;
}

.SyncMonitor-title {
  color: var(--text-primary);
  font-weight: bold;
  font-size: 16px;
  margin-right: 12px;
}

.SyncMonitor-badge {
  padding: 2px 8px;
  border-radius: 10px;
}

.SyncMonitor-badge.idle {
  background-color: var(--text-secondary);
}

.SyncMonitor-badge.syncing {
  background-color: var(--text-accent);
}

.SyncMonitor-badge-text {
  font-size: 10px;
  font-weight: bold;
  color: #fff;
}

.SyncMonitor-actions {
  display: flex;
  flex-direction: row;
  justify-content: flex-end;
}

.SyncMonitor-btn {
  padding: 6px 12px;
  border-radius: 4px;
  margin-left: 8px;
  background-color: var(--accent-soft);
}

.SyncMonitor-btn.primary {
  background-color: var(--text-accent);
}

.SyncMonitor-btn.danger {
  background-color: #d32f2f;
}

.SyncMonitor-btn:active {
  opacity: 0.8;
}

.SyncMonitor-btn-text {
  color: var(--text-accent);
  font-size: 12px;
  font-weight: bold;
}

.SyncMonitor-btn.primary .SyncMonitor-btn-text,
.SyncMonitor-btn.danger .SyncMonitor-btn-text {
  color: #fff;
}

.SyncMonitor-list {
  flex: 1;
  background-color: var(--bg-main);
  padding: 8px;
}

.SyncMonitor-item {
  background-color: var(--surface);
  border-radius: 4px;
  padding: 8px;
  margin-bottom: 8px;
  border: 1px solid var(--accent-border);
}

.SyncMonitor-item-header {
  display: flex;
  flex-direction: row;
  align-items: center;
  margin-bottom: 4px;
}

.SyncMonitor-op-type {
  font-size: 10px;
  font-weight: bold;
  padding: 2px 4px;
  border-radius: 2px;
  margin-right: 6px;
  color: #fff;
}

.SyncMonitor-op-type.UPSERT {
  background-color: #2e7d32;
}

.SyncMonitor-op-type.DELETE {
  background-color: #c62828;
}

.SyncMonitor-op-table {
  font-size: 12px;
  color: var(--text-secondary);
  font-weight: bold;
}

.SyncMonitor-op-payload {
  font-size: 10px;
  color: var(--text-secondary);
  font-family: monospace;
  margin-bottom: 4px;
}

.SyncMonitor-op-time {
  font-size: 9px;
  color: var(--text-secondary);
  text-align: right;
}

.SyncMonitor-empty {
  color: var(--text-secondary);
  text-align: center;
  margin-top: 40px;
  font-size: 14px;
}

.SyncMonitor-footer {
  padding: 8px;
  background-color: var(--glass);
  border-top: 1px solid var(--accent-border);
}

.SyncMonitor-footer-text {
  font-size: 10px;
  color: var(--text-secondary);
  text-align: center;
}


--------------------------------

FILE: components/SyncMonitor.tsx
SIZE: 2.80 KB
TYPE: tsx

CONTENT:
import { useEffect, useState } from '@lynx-js/react';
import { StorageService } from '../services/storage';
import { type Operation, SyncEngine } from '../services/sync';
import './SyncMonitor.css';

export function SyncMonitor() {
  const [queue, setQueue] = useState<Operation[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);
  const [deviceId, setDeviceId] = useState('');

  const refresh = async () => {
    const q = await SyncEngine.getQueue();
    setQueue(q);
    setIsSyncing(SyncEngine.isSyncing());
  };

  useEffect(() => {
    setDeviceId(StorageService.getDeviceId());
    refresh();

    // Subscribe to SyncEngine updates
    return SyncEngine.subscribe(() => {
      refresh();
    });
  }, []);

  const handleProcess = () => {
    SyncEngine.processQueue();
  };

  const handleClearQueue = async () => {
    // Only for dev debugging - might be dangerous
    await SyncEngine.saveQueue([]);
    refresh();
  };

  return (
    <view className="SyncMonitor">
      <view className="SyncMonitor-header">
        <view className="SyncMonitor-status-row">
          <text className="SyncMonitor-title">Queue: {queue.length}</text>
          <view
            className={`SyncMonitor-badge ${isSyncing ? 'syncing' : 'idle'}`}
          >
            <text className="SyncMonitor-badge-text">
              {isSyncing ? 'SYNCING...' : 'IDLE'}
            </text>
          </view>
        </view>

        <view className="SyncMonitor-actions">
          <view className="SyncMonitor-btn danger" bindtap={handleClearQueue}>
            <text className="SyncMonitor-btn-text">Clear</text>
          </view>
          <view className="SyncMonitor-btn primary" bindtap={handleProcess}>
            <text className="SyncMonitor-btn-text">Process Now</text>
          </view>
        </view>
      </view>

      <scroll-view className="SyncMonitor-list" scroll-y>
        {queue.map((op, i) => (
          <view key={i} className="SyncMonitor-item">
            <view className="SyncMonitor-item-header">
              <text className={`SyncMonitor-op-type ${op.type}`}>
                {op.type}
              </text>
              <text className="SyncMonitor-op-table">{op.table}</text>
            </view>
            <text className="SyncMonitor-op-payload">
              {JSON.stringify(op.payload || {}, null, 2)}
            </text>
            <text className="SyncMonitor-op-time">
              {new Date(op.timestamp).toLocaleTimeString()}
            </text>
          </view>
        ))}
        {queue.length === 0 && (
          <text className="SyncMonitor-empty">
            Queue is empty. Local changes synced.
          </text>
        )}
      </scroll-view>

      <view className="SyncMonitor-footer">
        <text className="SyncMonitor-footer-text">Device ID: {deviceId}</text>
      </view>
    </view>
  );
}


--------------------------------

FILE: tsconfig.json
SIZE: 342 bytes
TYPE: json

CONTENT:
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "composite": true,
    "jsx": "react-jsx",
    "jsxImportSource": "@lynx-js/react",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "noEmit": true,
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"]
  },
  "include": ["./**/*.ts", "./**/*.tsx"]
}


--------------------------------

FILE: config.ts
SIZE: 5.37 KB
TYPE: ts

CONTENT:
// Centralized Configuration
// All magic numbers, URLs, and environment constants in one place

// ============================================================
// SUPABASE
// ============================================================
export const SUPABASE_URL = 'https://exymyvbkjsttqsnifedq.supabase.co';
export const SUPABASE_REST_URL = `${SUPABASE_URL}/rest/v1`;
export const SUPABASE_ANON_KEY =
  'sb_publishable_tyLE5ronU6B5LAGta5GBjA_ZSqpzHyz';

// ============================================================
// GITHUB / OTA
// ============================================================
export const GITHUB_REPO = 'CodingInCarhartts/SMUTHUB';
export const GITHUB_RAW_BASE = `https://raw.githubusercontent.com/${GITHUB_REPO}`;
export const DEFAULT_OTA_BUNDLE_URL = `${GITHUB_RAW_BASE}/main/main.lynx.bundle`;

// ============================================================
// BATO MIRRORS
export const BATO_MIRRORS = [
  'https://mto.to',
  'https://ato.to',
  'https://dto.to',
  'https://fto.to',
  'https://hto.to',
  'https://jto.to',
  'https://lto.to',
  'https://nto.to',
  'https://vto.to',
  'https://wto.to',
  'https://xto.to',
  'https://yto.to',
  'https://vba.to',
  'https://wba.to',
  'https://xba.to',
  'https://yba.to',
  'https://zba.to',
  'https://bato.ac',
  'https://bato.bz',
  'https://bato.cc',
  'https://bato.cx',
  'https://bato.id',
  'https://bato.pw',
  'https://bato.sh',
  'https://bato.to',
  'https://bato.vc',
  'https://bato.day',
  'https://bato.red',
  'https://bato.run',
  'https://batoto.in',
  'https://batoto.tv',
  'https://batotoo.com',
  'https://batotwo.com',
  'https://batpub.com',
  'https://batread.com',
  'https://battwo.com',
  'https://xbato.com',
  'https://xbato.net',
  'https://xbato.org',
  'https://zbato.com',
  'https://zbato.net',
  'https://zbato.org',
  'https://comiko.net',
  'https://comiko.org',
  'https://mangatoto.com',
  'https://mangatoto.net',
  'https://mangatoto.org',
  'https://batocomic.com',
  'https://batocomic.net',
  'https://batocomic.org',
  'https://readtoto.com',
  'https://readtoto.net',
  'https://readtoto.org',
  'https://kuku.to',
  'https://okok.to',
  'https://ruru.to',
  'https://xdxd.to',
];

// ============================================================
// STORAGE LIMITS
// ============================================================
export const HISTORY_LIMIT_LOCAL = 50;
export const HISTORY_LIMIT_CLOUD = 999;
export const MAX_DEBUG_LOGS = 1000;

// ============================================================
// TIMEOUTS (in milliseconds)
// ============================================================
export const MIRROR_TIMEOUT_MS = 5000; // Timeout for each mirror check
export const NATIVE_DEVICE_ID_TIMEOUT_MS = 2000; // Timeout for native getDeviceId
export const STORAGE_INIT_TIMEOUT_MS = 5000; // Timeout for storage initialization
export const UPDATE_CHECK_COOLDOWN_MS = 30000; // Cooldown between update checks
export const SYNC_HEARTBEAT_INTERVAL_MS = 30000; // Background sync interval
export const READER_POSITION_SAVE_DELAY_MS = 1000; // Debounce for saving reader position
export const READER_RESTORE_DELAY_MS = 100; // Delay before allowing position tracking
export const STATUS_CLEAR_DELAY_MS = 3000; // Clear status messages after this time
export const PANEL_RETRY_DELAY_MS = 500; // Delay between panel load retries

// ============================================================
// UI / UX CONSTANTS
// ============================================================
export const SWIPE_THRESHOLD_PX = 50; // Minimum pixels for swipe detection
export const KEY_DEBOUNCE_MS = 50; // Debounce for keyboard/remote input
export const SCROLL_PERCENT = 0.1; // Scroll 10% of screen per key press
export const PANEL_MAX_RETRIES = 5; // Max retries for loading a panel image
export const REMOTE_TOUCH_DIVIDER_X = 500; // X coordinate threshold for up/down detection

export const DEFAULT_ASPECT_RATIO = 0.6;
export const BG_COLOR_DARK = '#1a1a1a';
export const MIN_PANEL_HEIGHT = '400px';

export const RETRY_DELAY_BASE = 500;
export const RETRY_DELAY_INCREMENT = 200;

// ============================================================
// CONTACT INFO
// ============================================================
export const SUPPORT_EMAIL = 'yumlabs.team@gmail.com';

// ============================================================
// USER AGENTS (for scraping)
// ============================================================
export const USER_AGENTS = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36',
];
// ============================================================
// VISUAL EVENTS
// ============================================================
export const ACTIVE_EVENT = {
  enabled: true,
  icon: '🌸',
  color: '#f7bfcaff',
  mode: 'drift', // 'sparkle' (pop) | 'fall' (snow/sakura) | 'drift' (heart/bubble)
};

/* 
  EVENT PRESETS:
  
  Sakura (Spring): 
  { icon: '🌸', color: '#FFB7C5', mode: 'fall' }
  
  Love (Valentine):
  { icon: '❤️', color: '#FF4D4D', mode: 'drift' }
  
  Snow (Winter):
  { icon: '❄️', color: '#B0E2FF', mode: 'fall' }
  
  Classic (Default):
  { icon: '✦', color: '#FFC000', mode: 'sparkle' }
*/


--------------------------------

FILE: App.tsx
SIZE: 22.97 KB
TYPE: tsx

CONTENT:
// Initialize debug log capture FIRST so all logs are captured

import {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from '@lynx-js/react';
import { BottomNav } from './components/BottomNav';
import { ErrorBoundary } from './components/ErrorBoundary';
import { FavoritesView } from './components/FavoritesView';
import { HistoryView } from './components/HistoryView';
import { MangaCard } from './components/MangaCard';
import { MangaDetailsUi } from './components/MangaDetailsUi';
import { Reader } from './components/Reader';
import { Search } from './components/Search';
import { SearchFiltersModal } from './components/SearchFilters';
import { Settings } from './components/Settings';
import { Sparkles } from './components/Sparkles';
import { UpdateModal } from './components/UpdateModal';
import { logCapture } from './services/debugLog';
import { SettingsStore } from './services/settings';
import { sourceManager } from './services/sourceManager';
import { normalizeUrl, StorageService } from './services/storage';
import type {
  Chapter,
  Manga,
  MangaDetails,
  SearchFilters,
} from './services/types';
import {
  type AppUpdate,
  BUNDLE_VERSION,
  type NativeAppUpdate,
  UpdateService,
} from './services/update';
import './App.css';

// Helper for debug logging
const log = (...args: any[]) => logCapture('log', ...args);
const logError = (...args: any[]) => logCapture('error', ...args);
const logWarn = (...args: any[]) => logCapture('warn', ...args);

type Tab = 'home' | 'search' | 'settings';
type ViewState = 'browse' | 'details' | 'reader';
type SettingsSubview = 'main' | 'favorites' | 'history';

export function App() {
  const [tab, setTab] = useState<Tab>('home');
  const [view, setView] = useState<ViewState>('browse');
  const [mangas, setMangas] = useState<Manga[]>([]);
  const [popularMangas, setPopularMangas] = useState<Manga[]>([]);
  const [latestMangas, setLatestMangas] = useState<Manga[]>([]);
  const [selectedManga, setSelectedManga] = useState<Manga | null>(null);
  const [mangaDetails, setMangaDetails] = useState<MangaDetails | null>(null);
  const [selectedChapterUrl, setSelectedChapterUrl] = useState<string>('');
  const [selectedChapterTitle, setSelectedChapterTitle] = useState<string>('');
  const [loading, setLoading] = useState(false);
  const [homeLoading, setHomeLoading] = useState(true);
  const [homeError, setHomeError] = useState<string | null>(null);

  // Search & Filter State
  const [showFilters, setShowFilters] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [currentFilters, setCurrentFilters] = useState<
    SearchFilters | undefined
  >(undefined);

  // Settings subviews
  const [settingsSubview, setSettingsSubview] =
    useState<SettingsSubview>('main');

  // Initialization state
  const [isReady, setIsReady] = useState(SettingsStore.isInitialized());
  const [darkMode, setDarkMode] = useState(false);
  const [debugOutlines, setDebugOutlines] = useState(false);

  // OTA Update state
  const [pendingUpdate, setPendingUpdate] = useState<AppUpdate | null>(null);

  // Native APK Update state
  const [pendingNativeUpdate, setPendingNativeUpdate] =
    useState<NativeAppUpdate | null>(null);

  // Initialize settings and subscribe after mount
  useEffect(() => {
    const init = async () => {
      await SettingsStore.waitForInitialization();
      setIsReady(true);
      setDarkMode(SettingsStore.getDarkMode());
      setDebugOutlines(SettingsStore.getDebugOutlines());
    };
    init();

    const unsubscribe = SettingsStore.subscribe(() => {
      setDarkMode(SettingsStore.getDarkMode());
      setDebugOutlines(SettingsStore.getDebugOutlines());
    });
    return unsubscribe;
  }, []);

  const triggerUpdateCheck = useCallback(async () => {
    log('[App] Checking for OTA updates...');
    try {
      const update = await UpdateService.checkUpdate();
      if (update) {
        log('[App] OTA Update found:', update.version);
        setPendingUpdate(update);
      }
      log('[App] Checking for Native updates...');
      const nativeUpdate = await UpdateService.checkNativeUpdate();
      if (nativeUpdate) {
        log('[App] Native Update found:', nativeUpdate.version);
        setPendingNativeUpdate(nativeUpdate);
      }
    } catch (e) {
      logError('[App] Update check error:', e);
    }
  }, []);

  const fetchHomeFeed = useCallback(async () => {
    setHomeLoading(true);
    setHomeError(null);
    try {
      log('[App] fetchHomeFeed started');

      const source = sourceManager.getSource(sourceManager.getDefaultSource());
      if (!source) {
        throw new Error(
          `${sourceManager.getDefaultSource()} source not registered`,
        );
      }

      const feed = await source.getHomeFeed();
      setPopularMangas(feed.popular);
      setLatestMangas(feed.latest);

      if (feed.popular.length === 0 && feed.latest.length === 0) {
        setHomeError('Connected but found no content.');
      }
    } catch (e: any) {
      logError('[App] fetchHomeFeed failed:', e);
      setHomeError(
        e.message ||
          'Failed to connect to MangaPark. Site might be down or protected.',
      );
    } finally {
      setHomeLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchHomeFeed();

    const savedFilters = StorageService.getLastFilters();
    if (savedFilters) {
      setCurrentFilters(savedFilters);
      log('[App] Loaded saved filters:', savedFilters);
    }

    const timer = setTimeout(triggerUpdateCheck, 3000);
    return () => clearTimeout(timer);
  }, []);

  const loadBrowse = useCallback(async (filters?: SearchFilters) => {
    log('[App] Loading browse with filters:', JSON.stringify(filters));
    setLoading(true);
    try {
      const browseParams = {
        sort: filters?.sort || 'views_d030',
        genres: filters?.genres,
        status: filters?.status,
        word: (filters as any)?.word,
      };
      log('[App] Browse params:', JSON.stringify(browseParams));
      const results = await sourceManager.search(browseParams.word || '', {
        ...filters,
        sort: filters?.sort || 'views_d030',
        genres: filters?.genres || [],
        status: filters?.status || 'all',
        nsfw: false,
      });
      log(`[App] Browse loaded: ${results.length} items`);
      setMangas(results);
    } catch (error) {
      logError('[App] Browse error:', error as Error);
    } finally {
      setLoading(false);
    }
  }, []);

  const hasAttemptedInitialLoad = useRef(false);
  useEffect(() => {
    if (tab === 'search' && !hasAttemptedInitialLoad.current && !loading) {
      log('[App] Search tab selected, performing initial load...');
      hasAttemptedInitialLoad.current = true;
      loadBrowse();
    }
  }, [tab, loadBrowse, loading]);

  const handleRefresh = useCallback(async () => {
    log('[App] Refreshing home feed...');
    await fetchHomeFeed();
  }, [fetchHomeFeed]);

  const handleSearch = useCallback(
    async (q: string) => {
      log(`[App] handleSearch called with: "${q}"`);
      setSearchQuery(q);
      await loadBrowse({
        ...currentFilters,
        word: q,
      } as any);
    },
    [currentFilters, loadBrowse],
  );

  const handleApplyFilters = useCallback(
    async (filters: SearchFilters) => {
      log('[App] Applying filters:', filters);
      setCurrentFilters(filters);
      setShowFilters(false);
      StorageService.saveFilters(filters);
      await loadBrowse({
        ...filters,
        word: searchQuery,
      } as any);
    },
    [loadBrowse, searchQuery],
  );

  const handleSelectManga = useCallback(async (manga: Manga) => {
    log(`[App] SELECT_START: ${manga.title}`);
    console.log('SELECT_START:', manga.title);

    import('./services/storage')
      .then(({ StorageService }) => {
        StorageService.triggerDebugCapture();
      })
      .catch(() => {});

    setSelectedManga(manga);
    setView('details');
    setSettingsSubview('main');
    setLoading(true);

    const autoCaptureTimer = setTimeout(() => {
      log('[App] AUTO-CAPTURE TRIGGER');
      import('./services/storage').then(({ StorageService }) => {
        StorageService.triggerDebugCapture();
      });
    }, 10000);

    const source = sourceManager.resolveSource(
      manga.source || manga.url || manga.id,
    );
    log(`[App] SOURCE_RESOLVED: ${source?.id || 'NULL'}`);
    if (!source) {
      logError('[App] SOURCE_NULL');
      setLoading(false);
      clearTimeout(autoCaptureTimer);
      return;
    }
    log(`[App] FETCHING_DETAILS: manga.id=${manga.id}, manga.url=${manga.url}`);
    try {
      const details = await source.getMangaDetails(manga.id);
      log(
        `[App] DETAILS_OK: ${details?.title} ch:${details?.chapters?.length || 0}`,
      );
      setMangaDetails(details);
    } catch (e) {
      logError('[App] DETAILS_ERR:', e);
    }
    setLoading(false);
    clearTimeout(autoCaptureTimer);
  }, []);

  const handleHistorySelect = useCallback(
    async (manga: Manga, chapterUrl?: string, chapterTitle?: string) => {
      log(`[App] History resume: ${manga.title}`);
      setSelectedManga(manga);
      setSettingsSubview('main');

      if (chapterUrl) {
        setSelectedChapterUrl(chapterUrl);
        setSelectedChapterTitle(chapterTitle || '');
        setView('reader');

        try {
          const source = sourceManager.resolveSource(
            manga.source || manga.url || manga.id,
          );
          if (source) {
            const details = await source.getMangaDetails(manga.url || manga.id);
            if (details) {
              setMangaDetails(details);
              setSelectedManga(details);
              StorageService.addToHistory(details, chapterUrl, chapterTitle);
              log('[App] Refreshed history metadata for:', details.title);
            }
          }
        } catch (e) {
          logError(
            '[App] Failed to load details for history resume',
            e as Error,
          );
        }
      } else {
        handleSelectManga(manga);
      }
    },
    [handleSelectManga],
  );

  const handleSelectChapter = useCallback(
    (chapterUrl: string, chapterTitle?: string) => {
      setSelectedChapterUrl(chapterUrl);
      setSelectedChapterTitle(chapterTitle || '');
      setView('reader');

      if (selectedManga) {
        StorageService.addToHistory(selectedManga, chapterUrl, chapterTitle);
      }
    },
    [selectedManga],
  );

  const handleBack = useCallback(() => {
    if (view === 'reader') {
      setView('details');
      triggerUpdateCheck();
    } else if (view === 'details') {
      setView('browse');
    }
  }, [view, triggerUpdateCheck]);

  const handleNextChapter = useCallback(() => {
    if (!mangaDetails || !selectedChapterUrl) {
      logWarn('[App] handleNextChapter failed: No details or selected chapter');
      return;
    }

    const chapters = mangaDetails.chapters;
    const normalizedSelected = normalizeUrl(selectedChapterUrl);

    const currentIndex = chapters.findIndex(
      (c: Chapter) => normalizeUrl(c.url) === normalizedSelected,
    );

    if (currentIndex !== -1 && currentIndex > 0) {
      const nextChapter = chapters[currentIndex - 1];
      handleSelectChapter(nextChapter.url, nextChapter.title);
    } else {
      logWarn(
        `[App] Next chapter not found. Index: ${currentIndex}, Total: ${chapters.length}`,
      );
    }
  }, [mangaDetails, selectedChapterUrl, handleSelectChapter]);

  const hasNextChapter = useMemo(() => {
    if (!mangaDetails || !selectedChapterUrl) return false;
    const chapters = mangaDetails.chapters;
    const normalizedSelected = normalizeUrl(selectedChapterUrl);
    const currentIndex = chapters.findIndex(
      (c: Chapter) => normalizeUrl(c.url) === normalizedSelected,
    );
    return currentIndex !== -1 && currentIndex > 0;
  }, [mangaDetails, selectedChapterUrl]);

  const handleTabChange = useCallback(
    (newTab: Tab) => {
      setTab(newTab);
      setView('browse');
      if (newTab === 'home') {
        triggerUpdateCheck();
      }
    },
    [triggerUpdateCheck],
  );

  const handleGenreClick = useCallback(
    (genre: string) => {
      if (genre === 'For You') {
        setTab('search');
        handleApplyFilters({
          genres: [],
          sort: 'views_d030',
          status: 'all',
          nsfw: false,
        });
      } else {
        setTab('search');
        handleApplyFilters({
          genres: [genre.toLowerCase()],
          sort: 'views_d030',
          status: 'all',
          nsfw: false,
        });
      }
    },
    [handleApplyFilters],
  );

  const handleSeeAllNew = useCallback(() => {
    setTab('search');
    handleApplyFilters({
      genres: [],
      sort: 'latest',
      status: 'all',
      nsfw: false,
    });
  }, [handleApplyFilters]);

  if (!isReady) {
    return (
      <view className="Main">
        <view className="LoadingContainer">
          <view className="LoadingSpinner" />
          <text className="StatusText">Loading...</text>
        </view>
      </view>
    );
  }

  if (view === 'reader') {
    return (
      <Reader
        chapterUrl={selectedChapterUrl}
        chapterTitle={selectedChapterTitle}
        manga={selectedManga ?? undefined}
        onBack={handleBack}
        hasNextChapter={hasNextChapter}
        onNextChapter={handleNextChapter}
      />
    );
  }

  const randomHeaderTitle = useMemo(() => {
    const headerTitleRandom = ['I love you', 'Discover', 'Explore'];
    return headerTitleRandom[
      Math.floor(Math.random() * headerTitleRandom.length)
    ];
  }, []);

  const searchLoadingText =
    searchQuery.trim() && currentFilters?.genres?.length
      ? 'Filtering results...'
      : 'Searching the library...';

  return (
    <ErrorBoundary>
      <view
        className={`${darkMode ? 'Main dark-mode' : 'Main'}${debugOutlines ? ' debug-outlines' : ''}`}
      >
        <view
          className={view === 'browse' ? 'Content Content-with-nav' : 'Content'}
        >
          {view === 'details' && selectedManga && mangaDetails ? (
            <MangaDetailsUi
              details={mangaDetails}
              onBack={handleBack}
              onRead={handleSelectChapter}
            />
          ) : view === 'details' && selectedManga ? (
            <view className="LoadingContainer">
              <view className="LoadingPulse">
                <text className="LoadingIcon">📖</text>
              </view>
              <text className="StatusText">Opening the story...</text>
            </view>
          ) : null}

          {view === 'browse' && (
            <>
              {tab === 'home' && (
                <view className="Home">
                  <view className="HomeHeader">
                    <Sparkles>
                      <text className="HomeTitle">
                        Release {BUNDLE_VERSION} (Filters Fixed)
                      </text>
                    </Sparkles>
                  </view>
                  <scroll-view
                    className="MangaList"
                    scroll-y
                    bindscrolltoupper={handleRefresh}
                    upper-threshold={50}
                  >
                    {homeLoading ? (
                      <view className="LoadingContainer">
                        <view className="LoadingSpinner" />
                        <text className="StatusText">
                          Fetching latest updates...
                        </text>
                        <text className="SubStatusText">
                          Checking mirrors and resolving connection...
                        </text>
                      </view>
                    ) : homeError ? (
                      <view className="ErrorContainer">
                        <text className="ErrorIcon">📡</text>
                        <text className="ErrorTitle">Connection Issue</text>
                        <text className="StatusText">{homeError}</text>
                        <view className="RetryButton" bindtap={handleRefresh}>
                          <text className="RetryText">Try Again</text>
                        </view>
                      </view>
                    ) : (
                      <>
                        {popularMangas.length > 0 && (
                          <view
                            className="EditorialHero"
                            bindtap={() => handleSelectManga(popularMangas[0])}
                          >
                            <image
                              className="HeroImage"
                              src={popularMangas[0].cover}
                              mode="aspectFill"
                            />
                            <view className="HeroOverlay">
                              <text className="HeroTag">Trending Now</text>
                              <text className="HeroTitle">
                                {popularMangas[0].title}
                              </text>
                              <view className="HeroActions">
                                <view className="HeroReadButton">
                                  <text className="HeroReadText">Read Now</text>
                                </view>
                              </view>
                            </view>
                          </view>
                        )}

                        <view className="CategoryScrollContainer">
                          <scroll-view className="CategoryScroll" scroll-x>
                            {[
                              'For You',
                              'Romance',
                              'Action',
                              'Fantasy',
                              'Comedy',
                              'Isekai',
                              'Drama',
                            ].map((genre) => (
                              <view
                                key={genre}
                                className="CatPill"
                                bindtap={() => handleGenreClick(genre)}
                              >
                                <text className="CatText">{genre}</text>
                              </view>
                            ))}
                          </scroll-view>
                        </view>

                        <view className="SectionHeader">
                          <text className="SectionTitle">New Releases</text>
                          <text className="ViewAll" bindtap={handleSeeAllNew}>
                            See All
                          </text>
                        </view>

                        <view className="MangaGrid">
                          {latestMangas.length > 0 ? (
                            latestMangas.map((m) => (
                              <view key={m.id} className="GridItem">
                                <MangaCard
                                  manga={m}
                                  onSelect={handleSelectManga}
                                />
                              </view>
                            ))
                          ) : (
                            <text className="StatusText">
                              No updates found.
                            </text>
                          )}
                        </view>
                      </>
                    )}
                  </scroll-view>
                </view>
              )}

              {tab === 'search' && (
                <view className="SearchView">
                  <Search
                    onSearch={handleSearch}
                    onFilterClick={() => setShowFilters(true)}
                    value={searchQuery}
                  />
                  <scroll-view className="MangaList" scroll-y>
                    {loading ? (
                      <view className="LoadingContainer">
                        <view className="LoadingSpinner" />
                        <text className="StatusText">{searchLoadingText}</text>
                      </view>
                    ) : mangas.length > 0 ? (
                      mangas.map((m) => (
                        <MangaCard
                          key={m.id}
                          manga={m}
                          onSelect={handleSelectManga}
                        />
                      ))
                    ) : (
                      <view className="EmptyState">
                        <text className="EmptyIcon">
                          {searchQuery ? '😞' : '🔍'}
                        </text>
                        <text className="EmptyTitle">
                          {searchQuery
                            ? 'No Results Found'
                            : 'Start Your Search'}
                        </text>
                        <text className="EmptySubtitle">
                          {searchQuery
                            ? `We couldn't find anything for "${searchQuery}". Try different keywords.`
                            : 'Discover your next favorite manga by typing above.'}
                        </text>
                        {currentFilters && (
                          <text className="FilterStatus">
                            Filters active: {currentFilters.genres.length}{' '}
                            genres
                          </text>
                        )}
                      </view>
                    )}
                  </scroll-view>
                </view>
              )}

              {tab === 'settings' && (
                <>
                  {settingsSubview === 'main' && (
                    <Settings
                      onNavigate={(subview) => setSettingsSubview(subview)}
                    />
                  )}
                  {settingsSubview === 'favorites' && (
                    <FavoritesView
                      onBack={() => setSettingsSubview('main')}
                      onSelectManga={handleSelectManga}
                    />
                  )}
                  {settingsSubview === 'history' && (
                    <HistoryView
                      onBack={() => setSettingsSubview('main')}
                      onSelectHistoryItem={handleHistorySelect}
                    />
                  )}
                </>
              )}
            </>
          )}
        </view>

        {showFilters && (
          <SearchFiltersModal
            onApply={handleApplyFilters}
            onClose={() => setShowFilters(false)}
            onReset={() => setSearchQuery('')}
            initialFilters={currentFilters}
          />
        )}

        {view === 'browse' && (
          <BottomNav activeTab={tab} onTabChange={handleTabChange} />
        )}

        {pendingNativeUpdate && (
          <UpdateModal
            update={pendingNativeUpdate}
            nativeUrl={pendingNativeUpdate.url}
            onDismiss={() => {
              UpdateService.skipVersion(pendingNativeUpdate.version);
              setPendingNativeUpdate(null);
            }}
          />
        )}

        {!pendingNativeUpdate && pendingUpdate && (
          <UpdateModal
            update={pendingUpdate}
            onDismiss={() => {
              UpdateService.skipVersion(pendingUpdate.version);
              setPendingUpdate(null);
            }}
          />
        )}
      </view>
    </ErrorBoundary>
  );
}


--------------------------------

FILE: utils/formatters.ts
SIZE: 611 bytes
TYPE: ts

CONTENT:
export function timeAgo(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);

  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  if (diffDays < 7) return `${diffDays}d ago`;
  if (diffDays < 30) return `${Math.floor(diffDays / 7)}w ago`;
  return `${Math.floor(diffDays / 30)}mo ago`;
}


--------------------------------

FILE: App.css
SIZE: 6.09 KB
TYPE: css

CONTENT:
/* Lumina Design System - Variables & Main Shell */
.Main {
  /* Default (Light) Variables */
  --bg-main: #fcf9f9;
  --surface: #ffffff;
  --accent-soft: #fde2e4;
  --accent-border: #fad2e1;
  --text-primary: #4a3f3f;
  --text-secondary: #8e7c7c;
  --text-accent: #d47a94;
  --glass: rgba(255, 255, 255, 0.8);
  --shadow-soft: 0 10px 30px -10px rgba(212, 122, 148, 0.15);

  /* Layout */
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: var(--surface);
  /* Uses var immediately */
  min-height: 100%;
}

/* Dark Mode Variables Override */
.Main.dark-mode {
  --bg-main: #1a1a1a;
  --surface: #2d2d2d;
  --accent-soft: #3d2a2f;
  --accent-border: #4a3640;
  --text-primary: #f0e8e8;
  --text-secondary: #a89898;
  --text-accent: #e8a0b0;
  --glass: rgba(45, 45, 45, 0.9);
  --shadow-soft: 0 10px 30px -10px rgba(0, 0, 0, 0.4);
}

.Content {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.Content-with-nav {
  padding-bottom: 90px;
}

/* Home View */
.Home {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.HomeHeader {
  padding: 50px 24px 16px 24px;
  background-color: var(--glass);
  overflow: visible;
}

.HomeTitle {
  font-size: 28px;
  font-weight: 800;
  letter-spacing: -0.5px;
  color: var(--text-accent);
}

.DebugVersion {
  font-size: 10px;
  color: var(--text-secondary);
  opacity: 0.5;
  margin-top: 4px;
}

.MangaList {
  flex: 1;
}

/* Editorial Hero Section */
.EditorialHero {
  margin: 0 24px 24px 24px;
  height: 420px;
  border-radius: 32px;
  overflow: hidden;
  position: relative;
  box-shadow: var(--shadow-soft);
}

.HeroImage {
  width: 100%;
  height: 100%;
}

.HeroOverlay {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 40px 24px 24px 24px;
  background: linear-gradient(to top, rgba(74, 63, 63, 0.8), transparent);
}

.HeroTag {
  display: inline-flex;
  padding: 4px 12px;
  background-color: var(--accent-soft);
  color: var(--text-accent);
  border-radius: 100px;
  font-size: 11px;
  font-weight: 700;
  letter-spacing: 0.5px;
  margin-bottom: 12px;
}

.HeroTitle {
  font-size: 28px;
  font-weight: 700;
  line-height: 1.1;
  color: #ffffff;
  letter-spacing: -0.3px;
}

.HeroActions {
  display: flex;
  flex-direction: row;
  margin-top: 12px;
}

.HeroReadButton {
  padding: 12px 24px;
  border-radius: 12px;
  background-color: #ffffff;
}

.HeroReadText {
  color: var(--text-accent);
  font-weight: 700;
  font-size: 15px;
}

/* Category Scroll */
.CategoryScrollContainer {
  margin-bottom: 24px;
}

.CategoryScroll {
  padding: 0 24px;
  display: flex;
  flex-direction: row;
}

.CatPill {
  padding: 10px 20px;
  border-radius: 100px;
  background-color: var(--bg-main);
  border: 1px solid var(--accent-border);
  margin-right: 12px;
}

.CatPill.active {
  background-color: var(--text-accent);
  border-color: var(--text-accent);
}

.CatText {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-secondary);
}

.CatPill.active .CatText {
  color: #ffffff;
}

/* Section Header */
.SectionHeader {
  padding: 0 24px;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: flex-end;
  margin-bottom: 16px;
}

.SectionTitle {
  font-size: 18px;
  font-weight: 700;
  color: var(--text-primary);
}

.ViewAll {
  font-size: 14px;
  color: var(--text-accent);
  font-weight: 500;
}

/* Manga Grid */
.MangaGrid {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  padding: 0 24px;
}

.GridItem {
  width: 50%;
  padding: 0 10px 20px 0;
}

.GridItem:nth-child(2n) {
  padding: 0 0 20px 10px;
}

/* Search View */
.SearchView {
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: var(--bg-main);
}

.EmptyState {
  padding: 40px 24px;
  align-items: center;
}

.FilterStatus {
  font-size: 13px;
  color: var(--text-accent);
  margin-top: 8px;
}

/* Loading & Empty States */
.LoadingContainer {
  flex: 1;
  justify-content: center;
  align-items: center;
  padding: 80px 40px;
}

.LoadingSpinner {
  width: 48px;
  height: 48px;
  border-radius: 24px;
  border: 4px solid var(--accent-soft);
  border-top-color: var(--text-accent);
  animation: spin 1s linear infinite;
  margin-bottom: 20px;
}

.LoadingPulse {
  width: 120px;
  height: 120px;
  border-radius: 60px;
  background-color: var(--accent-soft);
  animation: pulse 2s ease-in-out infinite;
  justify-content: center;
  align-items: center;
  margin-bottom: 24px;
}

.LoadingIcon {
  font-size: 40px;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
}

@keyframes pulse {
  0% {
    transform: scale(0.95);
    opacity: 0.5;
  }

  50% {
    transform: scale(1.05);
    opacity: 0.8;
  }

  100% {
    transform: scale(0.95);
    opacity: 0.5;
  }
}

.StatusText {
  font-size: 17px;
  font-weight: 600;
  color: var(--text-primary);
  text-align: center;
  letter-spacing: -0.2px;
}

.SubStatusText {
  font-size: 13px;
  color: var(--text-secondary);
  margin-top: 8px;
  text-align: center;
}

.ErrorContainer {
  flex: 1;
  justify-content: center;
  align-items: center;
  padding: 80px 40px;
}

.ErrorIcon {
  font-size: 56px;
  margin-bottom: 20px;
}

.ErrorTitle {
  font-size: 22px;
  font-weight: 800;
  color: var(--text-accent);
  margin-bottom: 12px;
}

.RetryButton {
  margin-top: 32px;
  padding: 14px 40px;
  background-color: var(--text-accent);
  border-radius: 100px;
  box-shadow: var(--shadow-soft);
}

.RetryText {
  color: #ffffff;
  font-weight: 700;
  font-size: 16px;
}

.EmptyState {
  flex: 1;
  padding: 100px 40px;
  justify-content: center;
  align-items: center;
}

.EmptyIcon {
  font-size: 64px;
  margin-bottom: 24px;
  opacity: 0.5;
}

.EmptyTitle {
  font-size: 20px;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: 8px;
  text-align: center;
}

.EmptySubtitle {
  font-size: 15px;
  color: var(--text-secondary);
  text-align: center;
  line-height: 1.4;
}

/* Debug Overlay */
.debug-outlines view,
.debug-outlines text,
.debug-outlines image,
.debug-outlines scroll-view,
.debug-outlines list,
.debug-outlines list-item,
.debug-outlines input,
.debug-outlines switch {
  border: 1px solid red !important;
  /* Use brighter red and ensure it renders */
  opacity: 0.8;
}


--------------------------------

FILE: typing.d.ts
SIZE: 1.94 KB
TYPE: ts

CONTENT:
// Type declarations for Lynx Native Modules
// These interfaces define the bridge between JavaScript and native platform code

declare let NativeModules: {
  /**
   * Native local storage module using platform-specific persistent storage:
   * - Android: SharedPreferences
   * - iOS: NSUserDefaults
   * - HarmonyOS: Preferences
   */
  NativeLocalStorageModule: {
    setStorageItem(key: string, value: string): void;
    getStorageItem(key: string, callback: (value: string | null) => void): void;
    clearStorage(): void;
  };

  /**
   * System UI controls (Immersive mode, Brightness, Orientation)
   */
  NativeUIModule: {
    setImmersiveMode(enabled: boolean): void;
    setBrightness(brightness: number): void;
    setOrientation(
      orientation: 'portrait' | 'landscape' | 'sensor' | 'unspecified',
    ): void;
  };

  /**
   * Native Android Toast messages
   */
  NativeToastModule: {
    show(message: string, duration: 0 | 1): void;
  };

  /**
   * Haptic feedback (vibrations)
   */
  NativeHapticModule: {
    vibrate(effect: 'light' | 'medium' | 'heavy' | 'success' | 'error'): void;
  };

  /**
   * System utilities (Clipboard, Sharing, Performance)
   */
  NativeUtilsModule: {
    copyToClipboard(text: string): void;
    shareText(text: string, title: string): void;
    getDeviceId(callback: (id: string) => void): void;
    exitApp(): void;
    /**
     * Get battery status as JSON string
     * Returns: {"level": number, "isCharging": boolean, "temperature": number}
     */
    getBatteryStatus(callback: (json: string) => void): void;
    /**
     * Get memory info as JSON string
     * Returns: {"usedMb": number, "maxMb": number, "pssMb": number}
     */
    getMemoryInfo(callback: (json: string) => void): void;
  };

  /**
   * Native APK Updater
   */
  NativeUpdaterModule: {
    getNativeVersion(): string;
    installUpdate(url: string): void;
    setOtaUrl(url: string): void;
    triggerOtaReload(): void;
    clearOta(): void;
  };
};


--------------------------------

